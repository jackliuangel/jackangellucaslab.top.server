<!doctype html>
<html lang="en">

<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>MediaPipe Pose Camera Demo - Designed for Lucas and all the Kids who loves stickman animation</title>
        <style>
                :root {
                        --bg: #0b0f14;
                        --fg: #e8eef5;
                        --muted: #9fb0c3;
                        --accent: #67d1ff;
                }

                html,
                body {
                        height: 100%;
                        margin: 0;
                        background: var(--bg);
                        color: var(--fg);
                        font: 14px/1.4 system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
                }

                .wrap {
                        max-width: 1400px;
                        margin: 0 auto;
                        padding: 16px;
                        width: 100%;
                        box-sizing: border-box;
                }

                h1 {
                        font-size: 20px;
                        margin: 0 0 8px;
                }

                p {
                        color: var(--muted);
                        margin: 0 0 16px;
                }

                .grid {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        grid-template-rows: auto 1fr;
                        gap: 12px;
                        height: calc(100vh - 140px);
                        align-items: stretch;
                        min-height: 600px;
                }

                .video-pane {
                        grid-column: 1;
                        grid-row: 1;
                        min-height: 400px;
                        display: flex;
                        flex-direction: column;
                        overflow: visible;
                }

                /* 确保video-pane内容不被裁剪 */
                .video-pane h3 {
                        flex-shrink: 0;
                }

                .data-pane {
                        grid-column: 1;
                        grid-row: 2;
                        min-height: 200px;
                        overflow: auto;
                }

                .stickman-pane {
                        grid-column: 2;
                        grid-row: 1 / 3;
                        min-height: 0;
                }

                /* 平板设备响应式布局 */
                @media screen and (max-width: 1024px) {
                        .grid {
                                grid-template-columns: 1fr;
                                grid-template-rows: auto auto 1fr;
                                height: auto;
                                min-height: calc(100vh - 120px);
                        }

                        .video-pane {
                                grid-column: 1;
                                grid-row: 1;
                        }

                        .data-pane {
                                grid-column: 1;
                                grid-row: 2;
                        }

                        .stickman-pane {
                                grid-column: 1;
                                grid-row: 3;
                                min-height: 500px;
                        }

                        .wrap {
                                padding: 12px;
                        }
                }

                /* 手机设备响应式布局 */
                @media screen and (max-width: 768px) {
                        .wrap {
                                padding: 8px;
                        }

                        .grid {
                                gap: 8px;
                        }

                        .controls {
                                flex-direction: column;
                                align-items: stretch;
                        }

                        .controls button,
                        .controls label {
                                margin-bottom: 4px;
                                text-align: center;
                        }

                        .stickman-pane {
                                min-height: 400px;
                        }

                        .stickman-pane .stage {
                                height: 350px !important;
                                width: 100% !important;
                                max-width: calc(100vw - 32px);
                                display: flex !important;
                                align-items: center !important;
                                justify-content: center !important;
                        }

                        h1 {
                                font-size: 18px;
                        }

                        p {
                                font-size: 13px;
                        }
                }

                /* iPhone专门优化 */
                @media screen and (max-width: 480px) {
                        .stickman-pane {
                                min-height: 350px;
                        }

                        .stickman-pane .stage {
                                height: 300px !important;
                        }

                        .video-pane .stage {
                                height: 180px !important;
                        }
                }

                /* 横屏模式特殊处理 */
                @media screen and (max-height: 600px) and (orientation: landscape) {
                        .grid {
                                grid-template-columns: 1fr 1fr;
                                grid-template-rows: 1fr 1fr;
                                height: calc(100vh - 100px);
                        }

                        .video-pane {
                                grid-column: 1;
                                grid-row: 1;
                        }

                        .data-pane {
                                grid-column: 1;
                                grid-row: 2;
                        }

                        .stickman-pane {
                                grid-column: 2;
                                grid-row: 1 / 3;
                        }
                }

                .pane {
                        background: #0e141b;
                        border: 1px solid #1b2531;
                        border-radius: 16px;
                        padding: 16px;
                        box-shadow: 0 8px 24px rgba(0, 0, 0, .2);
                        overflow: visible;
                }

                /* video-pane特殊布局 */
                .video-pane.pane {
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                }

                .stage {
                        position: relative;
                        background: #06090e;
                        border-radius: 12px;
                        overflow: hidden;
                        width: 100%;
                        max-width: 100%;
                        flex-shrink: 0;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                }

                .video-pane .stage {
                        height: 200px;
                        width: 100%;
                        aspect-ratio: auto;
                }

                .controls {
                        flex-shrink: 0;
                        margin-top: auto;
                }

                /* 确保canvas在移动设备上正确缩放 */
                @media screen and (max-width: 768px) {
                        .stage {
                                border-radius: 8px;
                        }
                }

                video {
                        display: none;
                }

                canvas {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        display: block;
                }

                .controls {
                        display: flex;
                        gap: 8px;
                        flex-wrap: wrap;
                        margin: 8px 0 0;
                        flex-shrink: 0;
                }

                /* 确保video-pane中的controls始终可见 */
                .video-pane .controls {
                        margin-top: 8px;
                        z-index: 10;
                        position: relative;
                }

                /* 在大屏幕上确保按钮区域有足够空间 */
                @media screen and (min-width: 1025px) {
                        .video-pane {
                                min-height: 450px;
                        }

                        .video-pane .stage {
                                height: 280px;
                        }

                        .video-pane .controls {
                                margin-top: 12px;
                                min-height: 120px;
                        }
                }

                button,
                select,
                label {
                        background: #101823;
                        color: var(--fg);
                        border: 1px solid #1b2531;
                        border-radius: 10px;
                        padding: 8px 12px;
                        cursor: pointer;
                }

                button:hover {
                        border-color: #2a384a;
                }

                .led {
                        width: 10px;
                        height: 10px;
                        border-radius: 50%;
                        display: inline-block;
                        margin-right: 6px;
                        background: #444;
                        box-shadow: 0 0 0 2px #1b2531 inset;
                }

                .led.on {
                        background: #1bd760;
                }

                pre {
                        white-space: pre-wrap;
                        word-break: break-word;
                        max-height: 58vh;
                        overflow: auto;
                        background: #0a1118;
                        border: 1px solid #132031;
                        border-radius: 10px;
                        padding: 12px;
                }

                .tip {
                        font-size: 12px;
                        color: #8aa0b7;
                }

                a {
                        color: var(--accent);
                }
        </style>
</head>

<body>
        <div class="wrap">
                <h1>MediaPipe Pose Camera Demo</h1>
                <p style="font-style: italic; color: var(--accent); margin-bottom: 8px;">Designed for Lucas and all the
                        Kids who loves stickman animation</p>
                <p>Click "Start" to authorize camera access. The page uses <b>MediaPipe Pose</b> to estimate human
                        poses. Top-left shows real-time camera feed, bottom-left displays keypoint coordinates, and the
                        right side shows real-time stickman preview with sky background.</p>

                <div class="grid">
                        <!-- Top-left: Real-time capture window -->
                        <div class="pane video-pane">
                                <h3 style="margin:0 0 12px">📹 Real-time Pose Capture</h3>
                                <div class="stage">
                                        <video id="video" playsinline></video>
                                        <canvas id="output"></canvas>
                                </div>
                                <div class="controls">
                                        <button id="startBtn">▶ Start</button>
                                        <button id="stopBtn" disabled>■ Stop</button>
                                        <button id="recordBtn" disabled>🎥 Record Animation</button>
                                        <button id="downloadBtn" disabled style="display:none">💾 Download
                                                Animation</button>
                                        <button id="manualDownloadBtn" disabled style="display:none">📥 Manual
                                                Download</button>
                                        <label><input type="checkbox" id="mirror" checked> Mirror Preview</label>
                                        <label><input type="checkbox" id="showIds"> Show IDs</label>
                                        <label><input type="checkbox" id="showBBox"> Show Bounding Box</label>
                                        <label><input type="checkbox" id="showTrunk" checked> Show Trunk</label>
                                        <label><input type="checkbox" id="showHandsFeet" checked> Show Hands &
                                                Feet</label>
                                        <span class="tip"><span id="led" class="led"></span><span id="status">Not
                                                        Started</span></span>
                                        <div id="recordingStatus"
                                                style="display:none; color: #ff6b6b; font-weight: bold;">
                                                🔴 Recording... <span id="recordingTimer">20</span>s
                                        </div>
                                </div>
                        </div>

                        <!-- Bottom-left: Keypoint coordinates data -->
                        <div class="pane data-pane">
                                <h3 style="margin:0 0 8px">📊 Keypoint Coordinates (Normalized x,y,z,visibility)</h3>
                                <pre id="json" style="max-height: 25vh;">[]</pre>

                                <div id="downloadInfo"
                                        style="margin-top:16px; padding:12px; background:#0a1118; border:1px solid #132031; border-radius:8px; display:none;">
                                        <h4 style="margin:0 0 8px; color:#67d1ff;">🎬 Recording Status</h4>
                                        <p style="margin:0 0 4px; color:#4ecdc4;" id="recordingInfo">Waiting to
                                                record...</p>
                                        <p style="margin:0; font-size:12px; color:#8aa0b7;">Download buttons will appear
                                                after recording completes</p>
                                </div>

                                <p class="tip" style="font-size: 11px; margin-top: 12px;">Ensure accessing this page via
                                        HTTPS or localhost, and allow browser camera permissions.</p>
                        </div>

                        <!-- Right side: Stickman preview (entire right half) -->
                        <div class="pane stickman-pane">
                                <h3 style="margin:0 0 12px">🌤️ Sky Stickman Preview</h3>
                                <div class="stage" style="aspect-ratio: auto; height: calc(100% - 100px);">
                                        <canvas id="trunkCanvas"></canvas>
                                </div>
                                <div
                                        style="margin-top:12px; padding:8px; background:#0a1118; border:1px solid #132031; border-radius:6px;">
                                        <p style="margin:0; font-size:12px; color:#8aa0b7;"><strong>🌤️ Sky Stickman
                                                        Features:</strong>
                                        </p>
                                        <p style="margin:4px 0 0; font-size:11px; color:#8aa0b7;">
                                                <span style="color:#ff6b6b;">● Big Round Head</span>: White glow + red
                                                circle<br />
                                                <span style="color:#4ecdc4;">● Arms</span>: Cyan lines + joint
                                                points<br />
                                                <span style="color:#00ffcc;">● Round Hands</span>: Doraemon-style
                                                circular palms<br />
                                                <span style="color:#ffa726;">● Legs</span>: Orange lines + joint
                                                points<br />
                                                <span style="color:#87CEEB;">● Background</span>: Real sky photo
                                        </p>
                                </div>
                        </div>
                </div>
        </div>

        <!-- MediaPipe Solutions CDN -->
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

        <script>
                const video = document.getElementById('video');
                const canvas = document.getElementById('output');
                const ctx = canvas.getContext('2d');
                const trunkCanvas = document.getElementById('trunkCanvas');
                const trunkCtx = trunkCanvas.getContext('2d');

                // 加载天空背景图片
                const skyImage = new Image();
                skyImage.crossOrigin = 'anonymous';
                skyImage.src = 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1000&q=80';
                let skyImageLoaded = false;

                skyImage.onload = function () {
                        skyImageLoaded = true;
                        console.log('Sky background image loaded successfully');
                };

                skyImage.onerror = function () {
                        console.log('Sky background image failed to load, using fallback image');
                        skyImage.src = 'https://picsum.photos/800/600?random=sky';
                };

                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const recordBtn = document.getElementById('recordBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                const manualDownloadBtn = document.getElementById('manualDownloadBtn');
                const mirror = document.getElementById('mirror');
                const showIds = document.getElementById('showIds');
                const showBBox = document.getElementById('showBBox');
                const showTrunk = document.getElementById('showTrunk');
                const showHandsFeet = document.getElementById('showHandsFeet');
                const jsonOut = document.getElementById('json');
                const led = document.getElementById('led');
                const statusEl = document.getElementById('status');
                const recordingStatus = document.getElementById('recordingStatus');
                const recordingTimer = document.getElementById('recordingTimer');
                const downloadInfo = document.getElementById('downloadInfo');
                const recordingInfo = document.getElementById('recordingInfo');

                let camera = null;
                let isRecording = false;
                let recordingData = [];
                let recordingStartTime = 0;
                let recordingInterval = null;

                function setStatus(txt, on = false) {
                        statusEl.textContent = txt;
                        led.classList.toggle('on', on);
                }

                function fitCanvasToVideo() {
                        const w = video.videoWidth || 1280;
                        const h = video.videoHeight || 720;
                        canvas.width = w;
                        canvas.height = h;

                        // 设置canvas显示尺寸，保持比例
                        const stage = canvas.parentElement;
                        const stageRect = stage.getBoundingClientRect();
                        const stageWidth = stageRect.width;
                        const stageHeight = stageRect.height;

                        // 计算适合的显示尺寸
                        const videoAspect = w / h;
                        const stageAspect = stageWidth / stageHeight;

                        let displayWidth, displayHeight;

                        if (videoAspect > stageAspect) {
                                // 视频更宽，以宽度为准
                                displayWidth = stageWidth;
                                displayHeight = stageWidth / videoAspect;
                        } else {
                                // 视频更高，以高度为准
                                displayHeight = stageHeight;
                                displayWidth = stageHeight * videoAspect;
                        }

                        // 应用显示尺寸
                        canvas.style.width = `${displayWidth}px`;
                        canvas.style.height = `${displayHeight}px`;

                        // 设置火柴人canvas适应容器大小（响应式）
                        const trunkContainer = trunkCanvas.parentElement;
                        const containerRect = trunkContainer.getBoundingClientRect();

                        let trunkSize;

                        // 移动端特殊处理
                        if (window.innerWidth <= 768) {
                                // 根据屏幕大小调整
                                let mobileSize;
                                if (window.innerWidth <= 480) {
                                        // iPhone等小屏幕
                                        mobileSize = Math.min(window.innerWidth * 0.9, 280);
                                } else {
                                        // 平板等中等屏幕
                                        mobileSize = Math.min(window.innerWidth * 0.8, 350);
                                }
                                trunkSize = Math.max(mobileSize, 250); // 最小250px

                                trunkCanvas.style.maxWidth = '100%';
                                trunkCanvas.style.height = 'auto';
                                trunkCanvas.style.display = 'block';
                                trunkCanvas.style.margin = '0 auto';
                        } else {
                                // 桌面端原有逻辑
                                const padding = 32;
                                const availableWidth = containerRect.width - padding;
                                const availableHeight = containerRect.height - padding;
                                trunkSize = Math.min(availableWidth, availableHeight, 800);
                        }

                        // 确保尺寸有效
                        trunkSize = Math.max(trunkSize, 200); // 最小200px

                        trunkCanvas.width = trunkSize;
                        trunkCanvas.height = trunkSize;

                        console.log(`Trunk canvas size: ${trunkSize}px (width: ${window.innerWidth}px)`);
                }

                /**
                 * 绘制身体躯干主要直线
                 * @param {CanvasRenderingContext2D} ctx - Canvas上下文
                 * @param {Array} pts - 关键点数组，每个点包含{x, y, z, v}
                 */
                function drawTrunkLines(ctx, pts) {
                        if (!pts || pts.length < 33) return; // MediaPipe Pose有33个关键点

                        ctx.save();
                        ctx.strokeStyle = '#ff6b6b'; // 红色躯干线条
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';

                        // 定义躯干主要连接线
                        const trunkConnections = [
                                // 头部到肩膀中心
                                [0, 'shoulderCenter'], // 鼻子到肩膀中心
                                // 肩膀横线
                                [11, 12], // 左肩到右肩
                                // 脊柱主线（肩膀中心到臀部中心）
                                ['shoulderCenter', 'hipCenter'],
                                // 臀部横线
                                [23, 24], // 左臀到右臀
                        ];

                        // 计算肩膀中心点和臀部中心点
                        const shoulderCenter = {
                                x: (pts[11].x + pts[12].x) / 2,
                                y: (pts[11].y + pts[12].y) / 2,
                                v: Math.min(pts[11].v, pts[12].v)
                        };

                        const hipCenter = {
                                x: (pts[23].x + pts[24].x) / 2,
                                y: (pts[23].y + pts[24].y) / 2,
                                v: Math.min(pts[23].v, pts[24].v)
                        };

                        // 绘制躯干连接线
                        trunkConnections.forEach(([start, end]) => {
                                let startPt, endPt;

                                if (start === 'shoulderCenter') {
                                        startPt = shoulderCenter;
                                } else if (start === 'hipCenter') {
                                        startPt = hipCenter;
                                } else {
                                        startPt = pts[start];
                                }

                                if (end === 'shoulderCenter') {
                                        endPt = shoulderCenter;
                                } else if (end === 'hipCenter') {
                                        endPt = hipCenter;
                                } else {
                                        endPt = pts[end];
                                }

                                // 只有当两个点的可见性都足够高时才绘制
                                if (startPt && endPt && startPt.v > 0.5 && endPt.v > 0.5) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // 绘制中心点标记
                        ctx.fillStyle = '#ff6b6b';
                        if (shoulderCenter.v > 0.5) {
                                ctx.beginPath();
                                ctx.arc(shoulderCenter.x, shoulderCenter.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                        }
                        if (hipCenter.v > 0.5) {
                                ctx.beginPath();
                                ctx.arc(hipCenter.x, hipCenter.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                        }

                        ctx.restore();
                }

                /**
                 * 在独立canvas上绘制躯干线条（简化视图）
                 * @param {Array} landmarks - MediaPipe姿态关键点
                 */
                function drawTrunkOnly(landmarks) {
                        if (!landmarks || landmarks.length < 33) {
                                // 清空canvas并显示等待信息
                                trunkCtx.clearRect(0, 0, trunkCanvas.width, trunkCanvas.height);
                                trunkCtx.fillStyle = '#8aa0b7';
                                trunkCtx.font = '14px system-ui';
                                trunkCtx.textAlign = 'center';
                                trunkCtx.fillText('Waiting for pose detection...', trunkCanvas.width / 2, trunkCanvas.height / 2);
                                return;
                        }

                        const w = trunkCanvas.width;
                        const h = trunkCanvas.height;
                        const centerX = w / 2;
                        const centerY = h / 2;

                        // 根据canvas尺寸动态调整缩放
                        const scale = Math.min(w, h) * 0.6; // 使用canvas尺寸的60%作为缩放

                        // 确保最小有效性
                        if (w < 10 || h < 10) {
                                console.log('Canvas too small:', w, h);
                                return;
                        }

                        // 转换关键点到canvas坐标
                        const pts = landmarks.map(l => ({
                                x: centerX + (l.x - 0.5) * scale,
                                y: centerY + (l.y - 0.5) * scale,
                                v: l.visibility
                        }));

                        trunkCtx.save();
                        trunkCtx.clearRect(0, 0, w, h);

                        // 应用镜像效果（与主窗口同步）
                        if (mirror.checked) {
                                trunkCtx.translate(w, 0);
                                trunkCtx.scale(-1, 1);
                        }

                        // 绘制天空背景
                        if (skyImageLoaded) {
                                // 计算图片适配尺寸，保持比例填充整个canvas
                                const imageAspect = skyImage.width / skyImage.height;
                                const canvasAspect = w / h;

                                let drawWidth, drawHeight, offsetX, offsetY;

                                if (imageAspect > canvasAspect) {
                                        // 图片更宽，以高度为基准
                                        drawHeight = h;
                                        drawWidth = h * imageAspect;
                                        offsetX = (w - drawWidth) / 2;
                                        offsetY = 0;
                                } else {
                                        // 图片更高，以宽度为基准
                                        drawWidth = w;
                                        drawHeight = w / imageAspect;
                                        offsetX = 0;
                                        offsetY = (h - drawHeight) / 2;
                                }

                                trunkCtx.drawImage(skyImage, offsetX, offsetY, drawWidth, drawHeight);

                                // 添加半透明覆盖层，让火柴人更突出
                                trunkCtx.fillStyle = 'rgba(11, 15, 20, 0.3)';
                                trunkCtx.fillRect(0, 0, w, h);
                        } else {
                                // 天空图片未加载时的渐变背景
                                const gradient = trunkCtx.createLinearGradient(0, 0, 0, h);
                                gradient.addColorStop(0, '#87CEEB'); // 天空蓝
                                gradient.addColorStop(0.7, '#E0F6FF'); // 浅蓝
                                gradient.addColorStop(1, '#FFFFFF'); // 白色
                                trunkCtx.fillStyle = gradient;
                                trunkCtx.fillRect(0, 0, w, h);
                        }

                        // 绘制轻微的网格线（更透明）
                        trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        trunkCtx.lineWidth = 0.5;
                        for (let i = 0; i <= w; i += 40) {
                                trunkCtx.beginPath();
                                trunkCtx.moveTo(i, 0);
                                trunkCtx.lineTo(i, h);
                                trunkCtx.stroke();
                        }
                        for (let i = 0; i <= h; i += 40) {
                                trunkCtx.beginPath();
                                trunkCtx.moveTo(0, i);
                                trunkCtx.lineTo(w, i);
                                trunkCtx.stroke();
                        }

                        // 绘制中心十字线（更亮一些）
                        trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        trunkCtx.lineWidth = 1;
                        trunkCtx.beginPath();
                        trunkCtx.moveTo(centerX, 0);
                        trunkCtx.lineTo(centerX, h);
                        trunkCtx.moveTo(0, centerY);
                        trunkCtx.lineTo(w, centerY);
                        trunkCtx.stroke();

                        // 计算肩膀中心点和臀部中心点
                        const shoulderCenter = {
                                x: (pts[11].x + pts[12].x) / 2,
                                y: (pts[11].y + pts[12].y) / 2,
                                v: Math.min(pts[11].v, pts[12].v)
                        };

                        const hipCenter = {
                                x: (pts[23].x + pts[24].x) / 2,
                                y: (pts[23].y + pts[24].y) / 2,
                                v: Math.min(pts[23].v, pts[24].v)
                        };

                        // 完整人体连接线定义（包含躯干、手臂、腿部、手指）
                        const bodyConnections = [
                                // 头部到肩膀中心
                                [0, 'shoulderCenter'],
                                // 肩膀横线
                                [11, 12],
                                // 脊柱主线
                                ['shoulderCenter', 'hipCenter'],
                                // 臀部横线
                                [23, 24],
                                // 左臂
                                [11, 13], // 左肩到左肘
                                [13, 15], // 左肘到左手腕
                                // 右臂
                                [12, 14], // 右肩到右肘
                                [14, 16], // 右肘到右手腕
                                // 左腿
                                [23, 25], // 左髋到左膝
                                [25, 27], // 左膝到左踝
                                [27, 31], // 左踝到左脚尖
                                // 右腿
                                [24, 26], // 右髋到右膝
                                [26, 28], // 右膝到右踝
                                [28, 32], // 右踝到右脚尖
                                // 手指部分已移除，改用圆形手掌代替
                        ];

                        // 绘制完整人体线条
                        trunkCtx.lineCap = 'round';

                        bodyConnections.forEach(([start, end]) => {
                                // 设置不同部位的颜色和线条粗细
                                let strokeColor = '#ff6b6b'; // 默认躯干颜色
                                let lineWidth = 4; // 默认躯干线宽

                                // 判断连接线类型并设置颜色和粗细
                                // 手指线段已移除，改用圆形手掌
                                // 肩膀到肘部 - 加粗50%：3 → 4.5
                                if (((start === 11 && end === 13) || (start === 13 && end === 11)) ||
                                        ((start === 12 && end === 14) || (start === 14 && end === 12))) {
                                        strokeColor = '#4ecdc4'; // 手臂颜色（青绿色）
                                        lineWidth = 4.5; // 3 * 1.5 = 4.5
                                }
                                // 肘部到手腕 - 保持不变：3px
                                else if (((start === 13 && end === 15) || (start === 15 && end === 13)) ||
                                        ((start === 14 && end === 16) || (start === 16 && end === 14))) {
                                        strokeColor = '#4ecdc4'; // 手臂颜色（青绿色）
                                        lineWidth = 3; // 保持原来的3px
                                }
                                // 大腿部分（髋部到膝盖）- 改为4.8px
                                else if (((start === 23 && end === 25) || (start === 25 && end === 23)) ||
                                        ((start === 24 && end === 26) || (start === 26 && end === 24))) {
                                        strokeColor = '#ffa726'; // 腿部颜色（橙色）
                                        lineWidth = 4.8; // 改为4.8px
                                }
                                // 小腿部分（膝盖到踝部、脚尖）- 保持不变：3.3px
                                else if (((start === 25 && end === 27) || (start === 27 && end === 25)) ||
                                        ((start === 26 && end === 28) || (start === 28 && end === 26)) ||
                                        ((start === 27 && end === 31) || (start === 31 && end === 27)) ||
                                        ((start === 28 && end === 32) || (start === 32 && end === 28))) {
                                        strokeColor = '#ffa726'; // 腿部颜色（橙色）
                                        lineWidth = 3.3; // 保持不变
                                }
                                // 躯干部分（头部、肩膀、脊柱、臀部）- 改为8px
                                else {
                                        strokeColor = '#ff6b6b'; // 躯干颜色（红色）
                                        lineWidth = 8; // 改为8px
                                }

                                trunkCtx.strokeStyle = strokeColor;
                                trunkCtx.lineWidth = lineWidth;
                                let startPt, endPt;

                                if (start === 'shoulderCenter') {
                                        startPt = shoulderCenter;
                                } else if (start === 'hipCenter') {
                                        startPt = hipCenter;
                                } else {
                                        startPt = pts[start];
                                }

                                if (end === 'shoulderCenter') {
                                        endPt = shoulderCenter;
                                } else if (end === 'hipCenter') {
                                        endPt = hipCenter;
                                } else {
                                        endPt = pts[end];
                                }

                                if (startPt && endPt && startPt.v > 0.5 && endPt.v > 0.5) {
                                        trunkCtx.beginPath();
                                        trunkCtx.moveTo(startPt.x, startPt.y);
                                        trunkCtx.lineTo(endPt.x, endPt.y);
                                        trunkCtx.stroke();
                                }
                        });

                        // 火柴人风格绘制

                        // 绘制头部大圆圈（在天空背景下更突出）
                        if (pts[0] && pts[0].v > 0.5) {
                                // 添加白色光晕效果
                                trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                                trunkCtx.lineWidth = 6;
                                trunkCtx.beginPath();
                                trunkCtx.arc(pts[0].x, pts[0].y, 16, 0, 2 * Math.PI);
                                trunkCtx.stroke();

                                // 主要头部圆圈
                                trunkCtx.strokeStyle = '#ff6b6b';
                                trunkCtx.fillStyle = 'rgba(255, 107, 107, 0.7)';
                                trunkCtx.lineWidth = 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(pts[0].x, pts[0].y, 16, 0, 2 * Math.PI); // 大圆圈头部
                                trunkCtx.fill();
                                trunkCtx.stroke();

                                // 绘制眼睛（黑点）
                                trunkCtx.fillStyle = '#000000';
                                trunkCtx.strokeStyle = '#000000';

                                // 左眼（从观察者角度看）
                                const leftEyeX = pts[0].x - 5;
                                const leftEyeY = pts[0].y - 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(leftEyeX, leftEyeY, 2, 0, 2 * Math.PI);
                                trunkCtx.fill();

                                // 右眼（从观察者角度看）
                                const rightEyeX = pts[0].x + 5;
                                const rightEyeY = pts[0].y - 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(rightEyeX, rightEyeY, 2, 0, 2 * Math.PI);
                                trunkCtx.fill();
                        }

                        // 绘制关节点（小圆圈）
                        // 躯干关节点（红色）
                        trunkCtx.fillStyle = '#ff6b6b';
                        trunkCtx.strokeStyle = '#ff6b6b';
                        trunkCtx.lineWidth = 2;
                        [11, 12, 23, 24].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.5) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // 手臂关节点（青绿色）
                        trunkCtx.fillStyle = '#4ecdc4';
                        trunkCtx.strokeStyle = '#4ecdc4';
                        [13, 14, 15, 16].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // 圆形手掌（多啦A梦风格）
                        trunkCtx.fillStyle = '#00ffcc';
                        trunkCtx.strokeStyle = '#00ffcc';
                        trunkCtx.lineWidth = 2;

                        // 左手掌 - 基于手腕位置 (index 15)
                        const leftWrist = pts[15];
                        if (leftWrist && leftWrist.v > 0.3) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(leftWrist.x, leftWrist.y, 8, 0, 2 * Math.PI); // 圆形手掌，半径8px
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // 右手掌 - 基于手腕位置 (index 16)
                        const rightWrist = pts[16];
                        if (rightWrist && rightWrist.v > 0.3) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(rightWrist.x, rightWrist.y, 8, 0, 2 * Math.PI); // 圆形手掌，半径8px
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // 腿部关节点（橙色）
                        trunkCtx.fillStyle = '#ffa726';
                        trunkCtx.strokeStyle = '#ffa726';
                        [25, 26, 27, 28].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // 脚部（小圆点）
                        trunkCtx.fillStyle = '#ffa726';
                        [31, 32].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 6, 0, 2 * Math.PI); // 脚部稍大一点
                                        trunkCtx.fill();
                                }
                        });

                        // 绘制中心点（火柴人风格 - 更小更简洁）
                        trunkCtx.fillStyle = '#67d1ff';
                        trunkCtx.strokeStyle = '#67d1ff';
                        trunkCtx.lineWidth = 2;
                        if (shoulderCenter.v > 0.5) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(shoulderCenter.x, shoulderCenter.y, 3, 0, 2 * Math.PI);
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }
                        if (hipCenter.v > 0.5) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(hipCenter.x, hipCenter.y, 3, 0, 2 * Math.PI);
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // 火柴人标签（在天空背景下更清晰）
                        trunkCtx.fillStyle = '#ffffff';
                        trunkCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        trunkCtx.lineWidth = 3;
                        trunkCtx.font = 'bold 10px system-ui';

                        // 根据镜像状态调整文字对齐方式和偏移
                        const isMirrored = mirror.checked;
                        trunkCtx.textAlign = isMirrored ? 'right' : 'left';
                        const textOffsetX = isMirrored ? -20 : 20;
                        const smallTextOffsetX = isMirrored ? -8 : 8;

                        // Head label (with stroke effect)
                        if (pts[0] && pts[0].v > 0.5) {
                                trunkCtx.strokeText('Head', pts[0].x + textOffsetX, pts[0].y - 8);
                                trunkCtx.fillText('Head', pts[0].x + textOffsetX, pts[0].y - 8);
                        }

                        // 手掌标签（多啦A梦风格圆形手掌）
                        trunkCtx.fillStyle = '#00ffcc';
                        trunkCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        trunkCtx.font = 'bold 9px system-ui';
                        trunkCtx.lineWidth = 2;

                        // 左手掌标签
                        if (pts[15] && pts[15].v > 0.3) {
                                const text = isMirrored ? 'R Hand' : 'L Hand';
                                trunkCtx.strokeText(text, pts[15].x + textOffsetX, pts[15].y + 15);
                                trunkCtx.fillText(text, pts[15].x + textOffsetX, pts[15].y + 15);
                        }

                        // 右手掌标签
                        if (pts[16] && pts[16].v > 0.3) {
                                const text = isMirrored ? 'L Hand' : 'R Hand';
                                trunkCtx.strokeText(text, pts[16].x + textOffsetX, pts[16].y + 15);
                                trunkCtx.fillText(text, pts[16].x + textOffsetX, pts[16].y + 15);
                        }

                        // Foot labels (simplified, with stroke)
                        if (pts[31] && pts[31].v > 0.3) {
                                const footText = isMirrored ? 'R Foot' : 'L Foot';
                                trunkCtx.strokeText(footText, pts[31].x + smallTextOffsetX, pts[31].y + 12);
                                trunkCtx.fillText(footText, pts[31].x + smallTextOffsetX, pts[31].y + 12);
                        }
                        if (pts[32] && pts[32].v > 0.3) {
                                const footText = isMirrored ? 'L Foot' : 'R Foot';
                                trunkCtx.strokeText(footText, pts[32].x + smallTextOffsetX, pts[32].y + 12);
                                trunkCtx.fillText(footText, pts[32].x + smallTextOffsetX, pts[32].y + 12);
                        }

                        trunkCtx.restore();
                }

                /**
                 * 绘制手部和脚部详细线段
                 * @param {CanvasRenderingContext2D} ctx - Canvas上下文
                 * @param {Array} pts - 关键点数组，每个点包含{x, y, z, v}
                 */
                function drawHandsAndFeetLines(ctx, pts) {
                        if (!pts || pts.length < 33) return; // MediaPipe Pose有33个关键点

                        ctx.save();
                        ctx.lineCap = 'round';

                        // 手部连接线定义（根据MediaPipe Pose关键点索引）
                        const handConnections = [
                                // 左手
                                [11, 13], // 左肩到左肘
                                [13, 15], // 左肘到左手腕
                                [15, 17], // 左手腕到左小指
                                [15, 19], // 左手腕到左食指
                                [15, 21], // 左手腕到左拇指
                                [17, 19], // 左小指到左食指

                                // 右手
                                [12, 14], // 右肩到右肘
                                [14, 16], // 右肘到右手腕
                                [16, 18], // 右手腕到右小指
                                [16, 20], // 右手腕到右食指
                                [16, 22], // 右手腕到右拇指
                                [18, 20], // 右小指到右食指
                        ];

                        // 脚部连接线定义
                        const feetConnections = [
                                // 左腿和脚
                                [23, 25], // 左髋到左膝
                                [25, 27], // 左膝到左踝
                                [27, 29], // 左踝到左脚跟
                                [27, 31], // 左踝到左脚尖
                                [29, 31], // 左脚跟到左脚尖

                                // 右腿和脚
                                [24, 26], // 右髋到右膝
                                [26, 28], // 右膝到右踝
                                [28, 30], // 右踝到右脚跟
                                [28, 32], // 右踝到右脚尖
                                [30, 32], // 右脚跟到右脚尖
                        ];

                        // 绘制手部线段（绿色）
                        ctx.strokeStyle = '#4ecdc4'; // 青绿色
                        ctx.lineWidth = 3;
                        handConnections.forEach(([start, end]) => {
                                const startPt = pts[start];
                                const endPt = pts[end];

                                // 只有当两个点的可见性都足够高时才绘制
                                if (startPt && endPt && startPt.v > 0.3 && endPt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // 绘制脚部线段（橙色）
                        ctx.strokeStyle = '#ffa726'; // 橙色
                        ctx.lineWidth = 3;
                        feetConnections.forEach(([start, end]) => {
                                const startPt = pts[start];
                                const endPt = pts[end];

                                // 只有当两个点的可见性都足够高时才绘制
                                if (startPt && endPt && startPt.v > 0.3 && endPt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // 绘制手部关键点标记（绿色）
                        ctx.fillStyle = '#4ecdc4';
                        [15, 16, 17, 18, 19, 20, 21, 22].forEach(idx => { // 手腕和手指关键点
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.arc(pt.x, pt.y, 2, 0, 2 * Math.PI);
                                        ctx.fill();
                                }
                        });

                        // 绘制脚部关键点标记（橙色）
                        ctx.fillStyle = '#ffa726';
                        [27, 28, 29, 30, 31, 32].forEach(idx => { // 踝部和脚部关键点
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.arc(pt.x, pt.y, 2, 0, 2 * Math.PI);
                                        ctx.fill();
                                }
                        });

                        ctx.restore();
                }

                function drawLandmarksAndSkeleton(landmarks) {
                        const w = canvas.width, h = canvas.height;
                        ctx.save();
                        ctx.clearRect(0, 0, w, h);
                        if (mirror.checked) { ctx.translate(w, 0); ctx.scale(-1, 1); }
                        ctx.drawImage(video, 0, 0, w, h);
                        if (!landmarks || landmarks.length === 0) { ctx.restore(); return; }
                        const pts = landmarks.map(l => ({ x: l.x * w, y: l.y * h, z: l.z, v: l.visibility }));
                        drawConnectors(ctx, pts, POSE_CONNECTIONS, { lineWidth: 3 });
                        drawLandmarks(ctx, pts, { radius: 4 });
                        if (showIds.checked) {
                                ctx.font = '12px system-ui'; ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,.4)'; ctx.lineWidth = 3;
                                pts.forEach((p, i) => { ctx.strokeText(String(i), p.x + 4, p.y - 4); ctx.fillText(String(i), p.x + 4, p.y - 4); });
                        }
                        if (showBBox.checked) {
                                const xs = pts.map(p => p.x), ys = pts.map(p => p.y);
                                ctx.strokeStyle = '#67d1ff'; ctx.lineWidth = 2;
                                ctx.strokeRect(Math.min(...xs), Math.min(...ys), Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));
                        }
                        if (showTrunk.checked) {
                                drawTrunkLines(ctx, pts);
                        }
                        if (showHandsFeet.checked) {
                                drawHandsAndFeetLines(ctx, pts);
                        }
                        ctx.restore();
                }

                /**
 * 开始录制姿态数据
 */
                function startRecording() {
                        if (isRecording) return;

                        isRecording = true;
                        recordingData = [];
                        recordingStartTime = Date.now();

                        recordBtn.disabled = true;
                        recordBtn.textContent = '🔴 Recording...';
                        recordingStatus.style.display = 'block';

                        // Show recording status information
                        downloadInfo.style.display = 'block';
                        recordingInfo.textContent = '🔴 Recording in progress...';
                        recordingInfo.style.color = '#ff6b6b';

                        // Countdown timer
                        let timeLeft = 20;
                        recordingTimer.textContent = timeLeft;

                        recordingInterval = setInterval(() => {
                                timeLeft--;
                                recordingTimer.textContent = timeLeft;
                                recordingInfo.textContent = `🔴 Recording... ${timeLeft}s remaining`;

                                if (timeLeft <= 0) {
                                        stopRecording();
                                }
                        }, 1000);

                        console.log('Starting animation data recording...');
                }

                /**
 * 停止录制姿态数据
 */
                function stopRecording() {
                        if (!isRecording) return;

                        isRecording = false;
                        clearInterval(recordingInterval);

                        recordBtn.disabled = false;
                        recordBtn.textContent = '🎥 Record Animation';
                        recordingStatus.style.display = 'none';

                        // 显示下载按钮
                        downloadBtn.style.display = 'inline-block';
                        downloadBtn.disabled = false;
                        manualDownloadBtn.style.display = 'inline-block';
                        manualDownloadBtn.disabled = false;

                        // 更新状态信息
                        recordingInfo.textContent = `✅ Recording completed! ${recordingData.length} frames collected`;
                        recordingInfo.style.color = '#4ecdc4';

                        console.log(`Recording completed! Collected ${recordingData.length} frames of data`);
                        console.log('Download buttons enabled, recordingData:', recordingData.length > 0 ? 'has data' : 'no data');

                        // More friendly prompt
                        const message = `🎉 Recording completed!\n\n📊 Collected ${recordingData.length} animation frames\n💾 Download buttons are now visible\n📱 Click buttons to export Pivot format file`;
                        alert(message);
                }

                /**
                 * 将MediaPipe关键点转换为Pivot Animation格式
                 * @param {Array} landmarks - MediaPipe姿态关键点
                 * @param {number} timestamp - 时间戳
                 * @returns {Object} Pivot格式的帧数据
                 */
                function convertToPivotFrame(landmarks, timestamp) {
                        if (!landmarks || landmarks.length < 33) return null;

                        // Pivot使用相对坐标系统，以画布中心为原点
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const scale = 100; // 缩放因子

                        // 主要关键点映射到Pivot骨架
                        const pivotPoints = {
                                // 头部
                                head: {
                                        x: Math.round((landmarks[0].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[0].y * canvas.height - centerY) / scale)
                                },
                                // 躯干
                                neck: {
                                        x: Math.round(((landmarks[11].x + landmarks[12].x) / 2 * canvas.width - centerX) / scale),
                                        y: Math.round(((landmarks[11].y + landmarks[12].y) / 2 * canvas.height - centerY) / scale)
                                },
                                torso: {
                                        x: Math.round(((landmarks[23].x + landmarks[24].x) / 2 * canvas.width - centerX) / scale),
                                        y: Math.round(((landmarks[23].y + landmarks[24].y) / 2 * canvas.height - centerY) / scale)
                                },
                                // 左臂
                                leftShoulder: {
                                        x: Math.round((landmarks[11].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[11].y * canvas.height - centerY) / scale)
                                },
                                leftElbow: {
                                        x: Math.round((landmarks[13].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[13].y * canvas.height - centerY) / scale)
                                },
                                leftHand: {
                                        x: Math.round((landmarks[15].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[15].y * canvas.height - centerY) / scale)
                                },
                                // 右臂
                                rightShoulder: {
                                        x: Math.round((landmarks[12].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[12].y * canvas.height - centerY) / scale)
                                },
                                rightElbow: {
                                        x: Math.round((landmarks[14].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[14].y * canvas.height - centerY) / scale)
                                },
                                rightHand: {
                                        x: Math.round((landmarks[16].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[16].y * canvas.height - centerY) / scale)
                                },
                                // 左腿
                                leftHip: {
                                        x: Math.round((landmarks[23].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[23].y * canvas.height - centerY) / scale)
                                },
                                leftKnee: {
                                        x: Math.round((landmarks[25].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[25].y * canvas.height - centerY) / scale)
                                },
                                leftFoot: {
                                        x: Math.round((landmarks[27].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[27].y * canvas.height - centerY) / scale)
                                },
                                // 右腿
                                rightHip: {
                                        x: Math.round((landmarks[24].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[24].y * canvas.height - centerY) / scale)
                                },
                                rightKnee: {
                                        x: Math.round((landmarks[26].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[26].y * canvas.height - centerY) / scale)
                                },
                                rightFoot: {
                                        x: Math.round((landmarks[28].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[28].y * canvas.height - centerY) / scale)
                                }
                        };

                        return {
                                frame: Math.floor(timestamp / 50), // 20fps
                                points: pivotPoints
                        };
                }

                /**
                 * 生成Pivot Animation格式的XML文件内容
                 * @param {Array} frames - 动画帧数据
                 * @returns {string} XML格式的动画文件内容
                 */
                function generatePivotXML(frames) {
                        const totalFrames = frames.length;
                        const fps = 20;

                        let xml = `<?xml version="1.0" encoding="UTF-8"?>
<animation>
    <info>
        <title>MediaPipe姿态动画</title>
        <author>MediaPipe Pose Recorder</author>
        <created>${new Date().toISOString()}</created>
        <frames>${totalFrames}</frames>
        <fps>${fps}</fps>
    </info>
    <figure>
        <segments>
            <!-- 头部 -->
            <segment id="head" color="#FFD700"/>
            <!-- 躯干 -->
            <segment id="neck" color="#FF6B6B"/>
            <segment id="torso" color="#FF6B6B"/>
            <!-- 左臂 -->
            <segment id="leftArm1" color="#4ECDC4"/>
            <segment id="leftArm2" color="#4ECDC4"/>
            <!-- 右臂 -->
            <segment id="rightArm1" color="#4ECDC4"/>
            <segment id="rightArm2" color="#4ECDC4"/>
            <!-- 左腿 -->
            <segment id="leftLeg1" color="#FFA726"/>
            <segment id="leftLeg2" color="#FFA726"/>
            <!-- 右腿 -->
            <segment id="rightLeg1" color="#FFA726"/>
            <segment id="rightLeg2" color="#FFA726"/>
        </segments>
    </figure>
    <frames>
`;

                        frames.forEach((frame, index) => {
                                const p = frame.points;
                                xml += `        <frame number="${index + 1}">
            <point id="head" x="${p.head.x}" y="${p.head.y}"/>
            <point id="neck" x="${p.neck.x}" y="${p.neck.y}"/>
            <point id="torso" x="${p.torso.x}" y="${p.torso.y}"/>
            <point id="leftShoulder" x="${p.leftShoulder.x}" y="${p.leftShoulder.y}"/>
            <point id="leftElbow" x="${p.leftElbow.x}" y="${p.leftElbow.y}"/>
            <point id="leftHand" x="${p.leftHand.x}" y="${p.leftHand.y}"/>
            <point id="rightShoulder" x="${p.rightShoulder.x}" y="${p.rightShoulder.y}"/>
            <point id="rightElbow" x="${p.rightElbow.x}" y="${p.rightElbow.y}"/>
            <point id="rightHand" x="${p.rightHand.x}" y="${p.rightHand.y}"/>
            <point id="leftHip" x="${p.leftHip.x}" y="${p.leftHip.y}"/>
            <point id="leftKnee" x="${p.leftKnee.x}" y="${p.leftKnee.y}"/>
            <point id="leftFoot" x="${p.leftFoot.x}" y="${p.leftFoot.y}"/>
            <point id="rightHip" x="${p.rightHip.x}" y="${p.rightHip.y}"/>
            <point id="rightKnee" x="${p.rightKnee.x}" y="${p.rightKnee.y}"/>
            <point id="rightFoot" x="${p.rightFoot.x}" y="${p.rightFoot.y}"/>
        </frame>
`;
                        });

                        xml += `    </frames>
</animation>`;

                        return xml;
                }

                /**
 * 下载Pivot动画文件
 */
                function downloadPivotAnimation() {
                        console.log('Download function called, data frames:', recordingData.length);

                        if (recordingData.length === 0) {
                                alert('❌ No recording data available for download\n\nPlease click "🎥 Record Animation" button to record for 20 seconds first.');
                                return;
                        }

                        try {
                                const xmlContent = generatePivotXML(recordingData);
                                console.log('XML content generated successfully, length:', xmlContent.length);

                                const blob = new Blob([xmlContent], { type: 'application/xml' });
                                const url = URL.createObjectURL(blob);

                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `pose_animation_${new Date().getTime()}.piv`;
                                a.style.display = 'none';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);

                                console.log('✅ Pivot animation file downloaded successfully');
                                alert('✅ Animation file downloaded successfully!\n\nFilename: pose_animation_xxx.piv\nYou can open this file in Pivot Animator to view your animation.');
                        } catch (error) {
                                console.error('Error during download:', error);
                                alert('❌ Download failed, please retry or refresh the page.\n\nError: ' + error.message);
                        }
                }

                /**
                 * 强制下载函数（备用方案）
                 */
                function forceDownload() {
                        console.log('Force download triggered');
                        if (recordingData.length === 0) {
                                // 创建示例数据用于测试
                                recordingData = [{
                                        frame: 0,
                                        points: {
                                                head: { x: 0, y: -50 },
                                                neck: { x: 0, y: -30 },
                                                torso: { x: 0, y: 20 },
                                                leftShoulder: { x: -20, y: -30 },
                                                leftElbow: { x: -40, y: -10 },
                                                leftHand: { x: -60, y: 10 },
                                                rightShoulder: { x: 20, y: -30 },
                                                rightElbow: { x: 40, y: -10 },
                                                rightHand: { x: 60, y: 10 },
                                                leftHip: { x: -10, y: 20 },
                                                leftKnee: { x: -10, y: 50 },
                                                leftFoot: { x: -10, y: 80 },
                                                rightHip: { x: 10, y: 20 },
                                                rightKnee: { x: 10, y: 50 },
                                                rightFoot: { x: 10, y: 80 }
                                        }
                                }];
                                alert('⚠️ Using sample data to create test file\n\nThis is a static test file, please record real motion data first.');
                        }
                        downloadPivotAnimation();
                }

                function onResults(results) {
                        drawLandmarksAndSkeleton(results.poseLandmarks);
                        drawTrunkOnly(results.poseLandmarks); // 在右侧面板显示躯干

                        if (results.poseLandmarks) {
                                const pretty = results.poseLandmarks.map((l, i) => ({ i, x: +l.x.toFixed(4), y: +l.y.toFixed(4), z: +l.z.toFixed(4), v: +(l.visibility ?? 0).toFixed(3) }));
                                jsonOut.textContent = JSON.stringify(pretty, null, 2);

                                // 录制期间收集姿态数据
                                if (isRecording) {
                                        const timestamp = Date.now() - recordingStartTime;
                                        const pivotFrame = convertToPivotFrame(results.poseLandmarks, timestamp);
                                        if (pivotFrame) {
                                                recordingData.push(pivotFrame);
                                        }
                                }
                        } else {
                                jsonOut.textContent = '[]';
                        }
                }

                const pose = new Pose({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
                pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, smoothSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                pose.onResults(onResults);

                async function start() {
                        setStatus('Initializing camera...');
                        try {
                                // 请求摄像头前先确认权限
                                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                                video.srcObject = stream;
                                await video.play();
                                camera = new Camera(video, { onFrame: async () => await pose.send({ image: video }), width: 1280, height: 720 });
                                await camera.start();
                                fitCanvasToVideo();
                                setStatus('Running', true);
                                startBtn.disabled = true;
                                stopBtn.disabled = false;
                                recordBtn.disabled = false; // 启用录制按钮
                                window.addEventListener('resize', fitCanvasToVideo);
                        } catch (err) {
                                console.error(err);
                                alert('Camera failed to start. Please check browser permissions and ensure page is accessed via HTTPS or localhost.\nError: ' + err.message);
                                setStatus('Start Failed');
                        }
                }

                async function stop() {
                        setStatus('Stopped');
                        if (camera) { camera.stop(); camera = null; }
                        if (video.srcObject) { video.srcObject.getTracks().forEach(t => t.stop()); video.srcObject = null; }
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                        recordBtn.disabled = true; // 禁用录制按钮
                        if (isRecording) stopRecording(); // 如果正在录制，停止录制
                        window.removeEventListener('resize', fitCanvasToVideo);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        trunkCtx.clearRect(0, 0, trunkCanvas.width, trunkCanvas.height);
                }

                startBtn.addEventListener('click', start);
                stopBtn.addEventListener('click', stop);
                recordBtn.addEventListener('click', startRecording);
                downloadBtn.addEventListener('click', downloadPivotAnimation);
                manualDownloadBtn.addEventListener('click', forceDownload);
                document.addEventListener('visibilitychange', () => { if (document.hidden && camera) stop(); });

                // 响应式布局：监听窗口大小变化
                let resizeTimeout;
                window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                                if (camera) {
                                        fitCanvasToVideo();
                                }
                        }, 250); // 防抖动，250ms后执行
                });

                // 设备方向变化监听
                window.addEventListener('orientationchange', () => {
                        setTimeout(() => {
                                if (camera) {
                                        fitCanvasToVideo();
                                }
                        }, 500); // 等待方向变化完成
                });

                // 页面加载完成后初始化火柴人canvas
                window.addEventListener('load', () => {
                        setTimeout(() => {
                                fitCanvasToVideo();
                        }, 100);
                });
        </script>
</body>

</html>

</html>
