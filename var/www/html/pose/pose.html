<!doctype html>
<html lang="en">

<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>MediaPipe Pose Camera Demo - Designed for Lucas and all the Kids who loves stickman animation</title>
        <style>
                :root {
                        --bg: #0b0f14;
                        --fg: #e8eef5;
                        --muted: #9fb0c3;
                        --accent: #67d1ff;
                }

                html,
                body {
                        height: 100%;
                        margin: 0;
                        background: var(--bg);
                        color: var(--fg);
                        font: 14px/1.4 system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial;
                }

                .wrap {
                        max-width: 1400px;
                        margin: 0 auto;
                        padding: 16px;
                        width: 100%;
                        box-sizing: border-box;
                }

                h1 {
                        font-size: 20px;
                        margin: 0 0 8px;
                }

                p {
                        color: var(--muted);
                        margin: 0 0 16px;
                }

                .grid {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        grid-template-rows: auto 1fr;
                        gap: 12px;
                        height: calc(100vh - 140px);
                        align-items: stretch;
                        min-height: 600px;
                }

                .video-pane {
                        grid-column: 1;
                        grid-row: 1;
                        min-height: 400px;
                        display: flex;
                        flex-direction: column;
                        overflow: visible;
                }

                /* ç¡®ä¿video-paneå†…å®¹ä¸è¢«è£å‰ª */
                .video-pane h3 {
                        flex-shrink: 0;
                }

                .data-pane {
                        grid-column: 1;
                        grid-row: 2;
                        min-height: 200px;
                        overflow: auto;
                }

                .stickman-pane {
                        grid-column: 2;
                        grid-row: 1 / 3;
                        min-height: 0;
                }

                /* å¹³æ¿è®¾å¤‡å“åº”å¼å¸ƒå±€ */
                @media screen and (max-width: 1024px) {
                        .grid {
                                grid-template-columns: 1fr;
                                grid-template-rows: auto auto 1fr;
                                height: auto;
                                min-height: calc(100vh - 120px);
                        }

                        .video-pane {
                                grid-column: 1;
                                grid-row: 1;
                        }

                        .data-pane {
                                grid-column: 1;
                                grid-row: 2;
                        }

                        .stickman-pane {
                                grid-column: 1;
                                grid-row: 3;
                                min-height: 500px;
                        }

                        .wrap {
                                padding: 12px;
                        }
                }

                /* æ‰‹æœºè®¾å¤‡å“åº”å¼å¸ƒå±€ */
                @media screen and (max-width: 768px) {
                        .wrap {
                                padding: 8px;
                        }

                        .grid {
                                gap: 8px;
                        }

                        .controls {
                                flex-direction: column;
                                align-items: stretch;
                        }

                        .controls button,
                        .controls label {
                                margin-bottom: 4px;
                                text-align: center;
                        }

                        .stickman-pane {
                                min-height: 400px;
                        }

                        .stickman-pane .stage {
                                height: 350px !important;
                                width: 100% !important;
                                max-width: calc(100vw - 32px);
                                display: flex !important;
                                align-items: center !important;
                                justify-content: center !important;
                        }

                        h1 {
                                font-size: 18px;
                        }

                        p {
                                font-size: 13px;
                        }
                }

                /* iPhoneä¸“é—¨ä¼˜åŒ– */
                @media screen and (max-width: 480px) {
                        .stickman-pane {
                                min-height: 350px;
                        }

                        .stickman-pane .stage {
                                height: 300px !important;
                        }

                        .video-pane .stage {
                                height: 180px !important;
                        }
                }

                /* æ¨ªå±æ¨¡å¼ç‰¹æ®Šå¤„ç† */
                @media screen and (max-height: 600px) and (orientation: landscape) {
                        .grid {
                                grid-template-columns: 1fr 1fr;
                                grid-template-rows: 1fr 1fr;
                                height: calc(100vh - 100px);
                        }

                        .video-pane {
                                grid-column: 1;
                                grid-row: 1;
                        }

                        .data-pane {
                                grid-column: 1;
                                grid-row: 2;
                        }

                        .stickman-pane {
                                grid-column: 2;
                                grid-row: 1 / 3;
                        }
                }

                .pane {
                        background: #0e141b;
                        border: 1px solid #1b2531;
                        border-radius: 16px;
                        padding: 16px;
                        box-shadow: 0 8px 24px rgba(0, 0, 0, .2);
                        overflow: visible;
                }

                /* video-paneç‰¹æ®Šå¸ƒå±€ */
                .video-pane.pane {
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                }

                .stage {
                        position: relative;
                        background: #06090e;
                        border-radius: 12px;
                        overflow: hidden;
                        width: 100%;
                        max-width: 100%;
                        flex-shrink: 0;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                }

                .video-pane .stage {
                        height: 200px;
                        width: 100%;
                        aspect-ratio: auto;
                }

                .controls {
                        flex-shrink: 0;
                        margin-top: auto;
                }

                /* ç¡®ä¿canvasåœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæ­£ç¡®ç¼©æ”¾ */
                @media screen and (max-width: 768px) {
                        .stage {
                                border-radius: 8px;
                        }
                }

                video {
                        display: none;
                }

                canvas {
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        display: block;
                }

                .controls {
                        display: flex;
                        gap: 8px;
                        flex-wrap: wrap;
                        margin: 8px 0 0;
                        flex-shrink: 0;
                }

                /* ç¡®ä¿video-paneä¸­çš„controlså§‹ç»ˆå¯è§ */
                .video-pane .controls {
                        margin-top: 8px;
                        z-index: 10;
                        position: relative;
                }

                /* åœ¨å¤§å±å¹•ä¸Šç¡®ä¿æŒ‰é’®åŒºåŸŸæœ‰è¶³å¤Ÿç©ºé—´ */
                @media screen and (min-width: 1025px) {
                        .video-pane {
                                min-height: 450px;
                        }

                        .video-pane .stage {
                                height: 280px;
                        }

                        .video-pane .controls {
                                margin-top: 12px;
                                min-height: 120px;
                        }
                }

                button,
                select,
                label {
                        background: #101823;
                        color: var(--fg);
                        border: 1px solid #1b2531;
                        border-radius: 10px;
                        padding: 8px 12px;
                        cursor: pointer;
                }

                button:hover {
                        border-color: #2a384a;
                }

                .led {
                        width: 10px;
                        height: 10px;
                        border-radius: 50%;
                        display: inline-block;
                        margin-right: 6px;
                        background: #444;
                        box-shadow: 0 0 0 2px #1b2531 inset;
                }

                .led.on {
                        background: #1bd760;
                }

                pre {
                        white-space: pre-wrap;
                        word-break: break-word;
                        max-height: 58vh;
                        overflow: auto;
                        background: #0a1118;
                        border: 1px solid #132031;
                        border-radius: 10px;
                        padding: 12px;
                }

                .tip {
                        font-size: 12px;
                        color: #8aa0b7;
                }

                a {
                        color: var(--accent);
                }
        </style>
</head>

<body>
        <div class="wrap">
                <h1>MediaPipe Pose Camera Demo</h1>
                <p style="font-style: italic; color: var(--accent); margin-bottom: 8px;">Designed for Lucas and all the
                        Kids who loves stickman animation</p>
                <p>Click "Start" to authorize camera access. The page uses <b>MediaPipe Pose</b> to estimate human
                        poses. Top-left shows real-time camera feed, bottom-left displays keypoint coordinates, and the
                        right side shows real-time stickman preview with sky background.</p>

                <div class="grid">
                        <!-- Top-left: Real-time capture window -->
                        <div class="pane video-pane">
                                <h3 style="margin:0 0 12px">ğŸ“¹ Real-time Pose Capture</h3>
                                <div class="stage">
                                        <video id="video" playsinline></video>
                                        <canvas id="output"></canvas>
                                </div>
                                <div class="controls">
                                        <button id="startBtn">â–¶ Start</button>
                                        <button id="stopBtn" disabled>â–  Stop</button>
                                        <button id="recordBtn" disabled>ğŸ¥ Record Animation</button>
                                        <button id="downloadBtn" disabled style="display:none">ğŸ’¾ Download
                                                Animation</button>
                                        <button id="manualDownloadBtn" disabled style="display:none">ğŸ“¥ Manual
                                                Download</button>
                                        <label><input type="checkbox" id="mirror" checked> Mirror Preview</label>
                                        <label><input type="checkbox" id="showIds"> Show IDs</label>
                                        <label><input type="checkbox" id="showBBox"> Show Bounding Box</label>
                                        <label><input type="checkbox" id="showTrunk" checked> Show Trunk</label>
                                        <label><input type="checkbox" id="showHandsFeet" checked> Show Hands &
                                                Feet</label>
                                        <span class="tip"><span id="led" class="led"></span><span id="status">Not
                                                        Started</span></span>
                                        <div id="recordingStatus"
                                                style="display:none; color: #ff6b6b; font-weight: bold;">
                                                ğŸ”´ Recording... <span id="recordingTimer">20</span>s
                                        </div>
                                </div>
                        </div>

                        <!-- Bottom-left: Keypoint coordinates data -->
                        <div class="pane data-pane">
                                <h3 style="margin:0 0 8px">ğŸ“Š Keypoint Coordinates (Normalized x,y,z,visibility)</h3>
                                <pre id="json" style="max-height: 25vh;">[]</pre>

                                <div id="downloadInfo"
                                        style="margin-top:16px; padding:12px; background:#0a1118; border:1px solid #132031; border-radius:8px; display:none;">
                                        <h4 style="margin:0 0 8px; color:#67d1ff;">ğŸ¬ Recording Status</h4>
                                        <p style="margin:0 0 4px; color:#4ecdc4;" id="recordingInfo">Waiting to
                                                record...</p>
                                        <p style="margin:0; font-size:12px; color:#8aa0b7;">Download buttons will appear
                                                after recording completes</p>
                                </div>

                                <p class="tip" style="font-size: 11px; margin-top: 12px;">Ensure accessing this page via
                                        HTTPS or localhost, and allow browser camera permissions.</p>
                        </div>

                        <!-- Right side: Stickman preview (entire right half) -->
                        <div class="pane stickman-pane">
                                <h3 style="margin:0 0 12px">ğŸŒ¤ï¸ Sky Stickman Preview</h3>
                                <div class="stage" style="aspect-ratio: auto; height: calc(100% - 100px);">
                                        <canvas id="trunkCanvas"></canvas>
                                </div>
                                <div
                                        style="margin-top:12px; padding:8px; background:#0a1118; border:1px solid #132031; border-radius:6px;">
                                        <p style="margin:0; font-size:12px; color:#8aa0b7;"><strong>ğŸŒ¤ï¸ Sky Stickman
                                                        Features:</strong>
                                        </p>
                                        <p style="margin:4px 0 0; font-size:11px; color:#8aa0b7;">
                                                <span style="color:#ff6b6b;">â— Big Round Head</span>: White glow + red
                                                circle<br />
                                                <span style="color:#4ecdc4;">â— Arms</span>: Cyan lines + joint
                                                points<br />
                                                <span style="color:#00ffcc;">â— Round Hands</span>: Doraemon-style
                                                circular palms<br />
                                                <span style="color:#ffa726;">â— Legs</span>: Orange lines + joint
                                                points<br />
                                                <span style="color:#87CEEB;">â— Background</span>: Real sky photo
                                        </p>
                                </div>
                        </div>
                </div>
        </div>

        <!-- MediaPipe Solutions CDN -->
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

        <script>
                const video = document.getElementById('video');
                const canvas = document.getElementById('output');
                const ctx = canvas.getContext('2d');
                const trunkCanvas = document.getElementById('trunkCanvas');
                const trunkCtx = trunkCanvas.getContext('2d');

                // åŠ è½½å¤©ç©ºèƒŒæ™¯å›¾ç‰‡
                const skyImage = new Image();
                skyImage.crossOrigin = 'anonymous';
                skyImage.src = 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=1000&q=80';
                let skyImageLoaded = false;

                skyImage.onload = function () {
                        skyImageLoaded = true;
                        console.log('Sky background image loaded successfully');
                };

                skyImage.onerror = function () {
                        console.log('Sky background image failed to load, using fallback image');
                        skyImage.src = 'https://picsum.photos/800/600?random=sky';
                };

                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const recordBtn = document.getElementById('recordBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                const manualDownloadBtn = document.getElementById('manualDownloadBtn');
                const mirror = document.getElementById('mirror');
                const showIds = document.getElementById('showIds');
                const showBBox = document.getElementById('showBBox');
                const showTrunk = document.getElementById('showTrunk');
                const showHandsFeet = document.getElementById('showHandsFeet');
                const jsonOut = document.getElementById('json');
                const led = document.getElementById('led');
                const statusEl = document.getElementById('status');
                const recordingStatus = document.getElementById('recordingStatus');
                const recordingTimer = document.getElementById('recordingTimer');
                const downloadInfo = document.getElementById('downloadInfo');
                const recordingInfo = document.getElementById('recordingInfo');

                let camera = null;
                let isRecording = false;
                let recordingData = [];
                let recordingStartTime = 0;
                let recordingInterval = null;

                function setStatus(txt, on = false) {
                        statusEl.textContent = txt;
                        led.classList.toggle('on', on);
                }

                function fitCanvasToVideo() {
                        const w = video.videoWidth || 1280;
                        const h = video.videoHeight || 720;
                        canvas.width = w;
                        canvas.height = h;

                        // è®¾ç½®canvasæ˜¾ç¤ºå°ºå¯¸ï¼Œä¿æŒæ¯”ä¾‹
                        const stage = canvas.parentElement;
                        const stageRect = stage.getBoundingClientRect();
                        const stageWidth = stageRect.width;
                        const stageHeight = stageRect.height;

                        // è®¡ç®—é€‚åˆçš„æ˜¾ç¤ºå°ºå¯¸
                        const videoAspect = w / h;
                        const stageAspect = stageWidth / stageHeight;

                        let displayWidth, displayHeight;

                        if (videoAspect > stageAspect) {
                                // è§†é¢‘æ›´å®½ï¼Œä»¥å®½åº¦ä¸ºå‡†
                                displayWidth = stageWidth;
                                displayHeight = stageWidth / videoAspect;
                        } else {
                                // è§†é¢‘æ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                                displayHeight = stageHeight;
                                displayWidth = stageHeight * videoAspect;
                        }

                        // åº”ç”¨æ˜¾ç¤ºå°ºå¯¸
                        canvas.style.width = `${displayWidth}px`;
                        canvas.style.height = `${displayHeight}px`;

                        // è®¾ç½®ç«æŸ´äººcanvasé€‚åº”å®¹å™¨å¤§å°ï¼ˆå“åº”å¼ï¼‰
                        const trunkContainer = trunkCanvas.parentElement;
                        const containerRect = trunkContainer.getBoundingClientRect();

                        let trunkSize;

                        // ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
                        if (window.innerWidth <= 768) {
                                // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´
                                let mobileSize;
                                if (window.innerWidth <= 480) {
                                        // iPhoneç­‰å°å±å¹•
                                        mobileSize = Math.min(window.innerWidth * 0.9, 280);
                                } else {
                                        // å¹³æ¿ç­‰ä¸­ç­‰å±å¹•
                                        mobileSize = Math.min(window.innerWidth * 0.8, 350);
                                }
                                trunkSize = Math.max(mobileSize, 250); // æœ€å°250px

                                trunkCanvas.style.maxWidth = '100%';
                                trunkCanvas.style.height = 'auto';
                                trunkCanvas.style.display = 'block';
                                trunkCanvas.style.margin = '0 auto';
                        } else {
                                // æ¡Œé¢ç«¯åŸæœ‰é€»è¾‘
                                const padding = 32;
                                const availableWidth = containerRect.width - padding;
                                const availableHeight = containerRect.height - padding;
                                trunkSize = Math.min(availableWidth, availableHeight, 800);
                        }

                        // ç¡®ä¿å°ºå¯¸æœ‰æ•ˆ
                        trunkSize = Math.max(trunkSize, 200); // æœ€å°200px

                        trunkCanvas.width = trunkSize;
                        trunkCanvas.height = trunkSize;

                        console.log(`Trunk canvas size: ${trunkSize}px (width: ${window.innerWidth}px)`);
                }

                /**
                 * ç»˜åˆ¶èº«ä½“èº¯å¹²ä¸»è¦ç›´çº¿
                 * @param {CanvasRenderingContext2D} ctx - Canvasä¸Šä¸‹æ–‡
                 * @param {Array} pts - å…³é”®ç‚¹æ•°ç»„ï¼Œæ¯ä¸ªç‚¹åŒ…å«{x, y, z, v}
                 */
                function drawTrunkLines(ctx, pts) {
                        if (!pts || pts.length < 33) return; // MediaPipe Poseæœ‰33ä¸ªå…³é”®ç‚¹

                        ctx.save();
                        ctx.strokeStyle = '#ff6b6b'; // çº¢è‰²èº¯å¹²çº¿æ¡
                        ctx.lineWidth = 4;
                        ctx.lineCap = 'round';

                        // å®šä¹‰èº¯å¹²ä¸»è¦è¿æ¥çº¿
                        const trunkConnections = [
                                // å¤´éƒ¨åˆ°è‚©è†€ä¸­å¿ƒ
                                [0, 'shoulderCenter'], // é¼»å­åˆ°è‚©è†€ä¸­å¿ƒ
                                // è‚©è†€æ¨ªçº¿
                                [11, 12], // å·¦è‚©åˆ°å³è‚©
                                // è„ŠæŸ±ä¸»çº¿ï¼ˆè‚©è†€ä¸­å¿ƒåˆ°è‡€éƒ¨ä¸­å¿ƒï¼‰
                                ['shoulderCenter', 'hipCenter'],
                                // è‡€éƒ¨æ¨ªçº¿
                                [23, 24], // å·¦è‡€åˆ°å³è‡€
                        ];

                        // è®¡ç®—è‚©è†€ä¸­å¿ƒç‚¹å’Œè‡€éƒ¨ä¸­å¿ƒç‚¹
                        const shoulderCenter = {
                                x: (pts[11].x + pts[12].x) / 2,
                                y: (pts[11].y + pts[12].y) / 2,
                                v: Math.min(pts[11].v, pts[12].v)
                        };

                        const hipCenter = {
                                x: (pts[23].x + pts[24].x) / 2,
                                y: (pts[23].y + pts[24].y) / 2,
                                v: Math.min(pts[23].v, pts[24].v)
                        };

                        // ç»˜åˆ¶èº¯å¹²è¿æ¥çº¿
                        trunkConnections.forEach(([start, end]) => {
                                let startPt, endPt;

                                if (start === 'shoulderCenter') {
                                        startPt = shoulderCenter;
                                } else if (start === 'hipCenter') {
                                        startPt = hipCenter;
                                } else {
                                        startPt = pts[start];
                                }

                                if (end === 'shoulderCenter') {
                                        endPt = shoulderCenter;
                                } else if (end === 'hipCenter') {
                                        endPt = hipCenter;
                                } else {
                                        endPt = pts[end];
                                }

                                // åªæœ‰å½“ä¸¤ä¸ªç‚¹çš„å¯è§æ€§éƒ½è¶³å¤Ÿé«˜æ—¶æ‰ç»˜åˆ¶
                                if (startPt && endPt && startPt.v > 0.5 && endPt.v > 0.5) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // ç»˜åˆ¶ä¸­å¿ƒç‚¹æ ‡è®°
                        ctx.fillStyle = '#ff6b6b';
                        if (shoulderCenter.v > 0.5) {
                                ctx.beginPath();
                                ctx.arc(shoulderCenter.x, shoulderCenter.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                        }
                        if (hipCenter.v > 0.5) {
                                ctx.beginPath();
                                ctx.arc(hipCenter.x, hipCenter.y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                        }

                        ctx.restore();
                }

                /**
                 * åœ¨ç‹¬ç«‹canvasä¸Šç»˜åˆ¶èº¯å¹²çº¿æ¡ï¼ˆç®€åŒ–è§†å›¾ï¼‰
                 * @param {Array} landmarks - MediaPipeå§¿æ€å…³é”®ç‚¹
                 */
                function drawTrunkOnly(landmarks) {
                        if (!landmarks || landmarks.length < 33) {
                                // æ¸…ç©ºcanvaså¹¶æ˜¾ç¤ºç­‰å¾…ä¿¡æ¯
                                trunkCtx.clearRect(0, 0, trunkCanvas.width, trunkCanvas.height);
                                trunkCtx.fillStyle = '#8aa0b7';
                                trunkCtx.font = '14px system-ui';
                                trunkCtx.textAlign = 'center';
                                trunkCtx.fillText('Waiting for pose detection...', trunkCanvas.width / 2, trunkCanvas.height / 2);
                                return;
                        }

                        const w = trunkCanvas.width;
                        const h = trunkCanvas.height;
                        const centerX = w / 2;
                        const centerY = h / 2;

                        // æ ¹æ®canvaså°ºå¯¸åŠ¨æ€è°ƒæ•´ç¼©æ”¾
                        const scale = Math.min(w, h) * 0.6; // ä½¿ç”¨canvaså°ºå¯¸çš„60%ä½œä¸ºç¼©æ”¾

                        // ç¡®ä¿æœ€å°æœ‰æ•ˆæ€§
                        if (w < 10 || h < 10) {
                                console.log('Canvas too small:', w, h);
                                return;
                        }

                        // è½¬æ¢å…³é”®ç‚¹åˆ°canvasåæ ‡
                        const pts = landmarks.map(l => ({
                                x: centerX + (l.x - 0.5) * scale,
                                y: centerY + (l.y - 0.5) * scale,
                                v: l.visibility
                        }));

                        trunkCtx.save();
                        trunkCtx.clearRect(0, 0, w, h);

                        // åº”ç”¨é•œåƒæ•ˆæœï¼ˆä¸ä¸»çª—å£åŒæ­¥ï¼‰
                        if (mirror.checked) {
                                trunkCtx.translate(w, 0);
                                trunkCtx.scale(-1, 1);
                        }

                        // ç»˜åˆ¶å¤©ç©ºèƒŒæ™¯
                        if (skyImageLoaded) {
                                // è®¡ç®—å›¾ç‰‡é€‚é…å°ºå¯¸ï¼Œä¿æŒæ¯”ä¾‹å¡«å……æ•´ä¸ªcanvas
                                const imageAspect = skyImage.width / skyImage.height;
                                const canvasAspect = w / h;

                                let drawWidth, drawHeight, offsetX, offsetY;

                                if (imageAspect > canvasAspect) {
                                        // å›¾ç‰‡æ›´å®½ï¼Œä»¥é«˜åº¦ä¸ºåŸºå‡†
                                        drawHeight = h;
                                        drawWidth = h * imageAspect;
                                        offsetX = (w - drawWidth) / 2;
                                        offsetY = 0;
                                } else {
                                        // å›¾ç‰‡æ›´é«˜ï¼Œä»¥å®½åº¦ä¸ºåŸºå‡†
                                        drawWidth = w;
                                        drawHeight = w / imageAspect;
                                        offsetX = 0;
                                        offsetY = (h - drawHeight) / 2;
                                }

                                trunkCtx.drawImage(skyImage, offsetX, offsetY, drawWidth, drawHeight);

                                // æ·»åŠ åŠé€æ˜è¦†ç›–å±‚ï¼Œè®©ç«æŸ´äººæ›´çªå‡º
                                trunkCtx.fillStyle = 'rgba(11, 15, 20, 0.3)';
                                trunkCtx.fillRect(0, 0, w, h);
                        } else {
                                // å¤©ç©ºå›¾ç‰‡æœªåŠ è½½æ—¶çš„æ¸å˜èƒŒæ™¯
                                const gradient = trunkCtx.createLinearGradient(0, 0, 0, h);
                                gradient.addColorStop(0, '#87CEEB'); // å¤©ç©ºè“
                                gradient.addColorStop(0.7, '#E0F6FF'); // æµ…è“
                                gradient.addColorStop(1, '#FFFFFF'); // ç™½è‰²
                                trunkCtx.fillStyle = gradient;
                                trunkCtx.fillRect(0, 0, w, h);
                        }

                        // ç»˜åˆ¶è½»å¾®çš„ç½‘æ ¼çº¿ï¼ˆæ›´é€æ˜ï¼‰
                        trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        trunkCtx.lineWidth = 0.5;
                        for (let i = 0; i <= w; i += 40) {
                                trunkCtx.beginPath();
                                trunkCtx.moveTo(i, 0);
                                trunkCtx.lineTo(i, h);
                                trunkCtx.stroke();
                        }
                        for (let i = 0; i <= h; i += 40) {
                                trunkCtx.beginPath();
                                trunkCtx.moveTo(0, i);
                                trunkCtx.lineTo(w, i);
                                trunkCtx.stroke();
                        }

                        // ç»˜åˆ¶ä¸­å¿ƒåå­—çº¿ï¼ˆæ›´äº®ä¸€äº›ï¼‰
                        trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        trunkCtx.lineWidth = 1;
                        trunkCtx.beginPath();
                        trunkCtx.moveTo(centerX, 0);
                        trunkCtx.lineTo(centerX, h);
                        trunkCtx.moveTo(0, centerY);
                        trunkCtx.lineTo(w, centerY);
                        trunkCtx.stroke();

                        // è®¡ç®—è‚©è†€ä¸­å¿ƒç‚¹å’Œè‡€éƒ¨ä¸­å¿ƒç‚¹
                        const shoulderCenter = {
                                x: (pts[11].x + pts[12].x) / 2,
                                y: (pts[11].y + pts[12].y) / 2,
                                v: Math.min(pts[11].v, pts[12].v)
                        };

                        const hipCenter = {
                                x: (pts[23].x + pts[24].x) / 2,
                                y: (pts[23].y + pts[24].y) / 2,
                                v: Math.min(pts[23].v, pts[24].v)
                        };

                        // å®Œæ•´äººä½“è¿æ¥çº¿å®šä¹‰ï¼ˆåŒ…å«èº¯å¹²ã€æ‰‹è‡‚ã€è…¿éƒ¨ã€æ‰‹æŒ‡ï¼‰
                        const bodyConnections = [
                                // å¤´éƒ¨åˆ°è‚©è†€ä¸­å¿ƒ
                                [0, 'shoulderCenter'],
                                // è‚©è†€æ¨ªçº¿
                                [11, 12],
                                // è„ŠæŸ±ä¸»çº¿
                                ['shoulderCenter', 'hipCenter'],
                                // è‡€éƒ¨æ¨ªçº¿
                                [23, 24],
                                // å·¦è‡‚
                                [11, 13], // å·¦è‚©åˆ°å·¦è‚˜
                                [13, 15], // å·¦è‚˜åˆ°å·¦æ‰‹è…•
                                // å³è‡‚
                                [12, 14], // å³è‚©åˆ°å³è‚˜
                                [14, 16], // å³è‚˜åˆ°å³æ‰‹è…•
                                // å·¦è…¿
                                [23, 25], // å·¦é«‹åˆ°å·¦è†
                                [25, 27], // å·¦è†åˆ°å·¦è¸
                                [27, 31], // å·¦è¸åˆ°å·¦è„šå°–
                                // å³è…¿
                                [24, 26], // å³é«‹åˆ°å³è†
                                [26, 28], // å³è†åˆ°å³è¸
                                [28, 32], // å³è¸åˆ°å³è„šå°–
                                // æ‰‹æŒ‡éƒ¨åˆ†å·²ç§»é™¤ï¼Œæ”¹ç”¨åœ†å½¢æ‰‹æŒä»£æ›¿
                        ];

                        // ç»˜åˆ¶å®Œæ•´äººä½“çº¿æ¡
                        trunkCtx.lineCap = 'round';

                        bodyConnections.forEach(([start, end]) => {
                                // è®¾ç½®ä¸åŒéƒ¨ä½çš„é¢œè‰²å’Œçº¿æ¡ç²—ç»†
                                let strokeColor = '#ff6b6b'; // é»˜è®¤èº¯å¹²é¢œè‰²
                                let lineWidth = 4; // é»˜è®¤èº¯å¹²çº¿å®½

                                // åˆ¤æ–­è¿æ¥çº¿ç±»å‹å¹¶è®¾ç½®é¢œè‰²å’Œç²—ç»†
                                // æ‰‹æŒ‡çº¿æ®µå·²ç§»é™¤ï¼Œæ”¹ç”¨åœ†å½¢æ‰‹æŒ
                                // è‚©è†€åˆ°è‚˜éƒ¨ - åŠ ç²—50%ï¼š3 â†’ 4.5
                                if (((start === 11 && end === 13) || (start === 13 && end === 11)) ||
                                        ((start === 12 && end === 14) || (start === 14 && end === 12))) {
                                        strokeColor = '#4ecdc4'; // æ‰‹è‡‚é¢œè‰²ï¼ˆé’ç»¿è‰²ï¼‰
                                        lineWidth = 4.5; // 3 * 1.5 = 4.5
                                }
                                // è‚˜éƒ¨åˆ°æ‰‹è…• - ä¿æŒä¸å˜ï¼š3px
                                else if (((start === 13 && end === 15) || (start === 15 && end === 13)) ||
                                        ((start === 14 && end === 16) || (start === 16 && end === 14))) {
                                        strokeColor = '#4ecdc4'; // æ‰‹è‡‚é¢œè‰²ï¼ˆé’ç»¿è‰²ï¼‰
                                        lineWidth = 3; // ä¿æŒåŸæ¥çš„3px
                                }
                                // å¤§è…¿éƒ¨åˆ†ï¼ˆé«‹éƒ¨åˆ°è†ç›–ï¼‰- æ”¹ä¸º4.8px
                                else if (((start === 23 && end === 25) || (start === 25 && end === 23)) ||
                                        ((start === 24 && end === 26) || (start === 26 && end === 24))) {
                                        strokeColor = '#ffa726'; // è…¿éƒ¨é¢œè‰²ï¼ˆæ©™è‰²ï¼‰
                                        lineWidth = 4.8; // æ”¹ä¸º4.8px
                                }
                                // å°è…¿éƒ¨åˆ†ï¼ˆè†ç›–åˆ°è¸éƒ¨ã€è„šå°–ï¼‰- ä¿æŒä¸å˜ï¼š3.3px
                                else if (((start === 25 && end === 27) || (start === 27 && end === 25)) ||
                                        ((start === 26 && end === 28) || (start === 28 && end === 26)) ||
                                        ((start === 27 && end === 31) || (start === 31 && end === 27)) ||
                                        ((start === 28 && end === 32) || (start === 32 && end === 28))) {
                                        strokeColor = '#ffa726'; // è…¿éƒ¨é¢œè‰²ï¼ˆæ©™è‰²ï¼‰
                                        lineWidth = 3.3; // ä¿æŒä¸å˜
                                }
                                // èº¯å¹²éƒ¨åˆ†ï¼ˆå¤´éƒ¨ã€è‚©è†€ã€è„ŠæŸ±ã€è‡€éƒ¨ï¼‰- æ”¹ä¸º8px
                                else {
                                        strokeColor = '#ff6b6b'; // èº¯å¹²é¢œè‰²ï¼ˆçº¢è‰²ï¼‰
                                        lineWidth = 8; // æ”¹ä¸º8px
                                }

                                trunkCtx.strokeStyle = strokeColor;
                                trunkCtx.lineWidth = lineWidth;
                                let startPt, endPt;

                                if (start === 'shoulderCenter') {
                                        startPt = shoulderCenter;
                                } else if (start === 'hipCenter') {
                                        startPt = hipCenter;
                                } else {
                                        startPt = pts[start];
                                }

                                if (end === 'shoulderCenter') {
                                        endPt = shoulderCenter;
                                } else if (end === 'hipCenter') {
                                        endPt = hipCenter;
                                } else {
                                        endPt = pts[end];
                                }

                                if (startPt && endPt && startPt.v > 0.5 && endPt.v > 0.5) {
                                        trunkCtx.beginPath();
                                        trunkCtx.moveTo(startPt.x, startPt.y);
                                        trunkCtx.lineTo(endPt.x, endPt.y);
                                        trunkCtx.stroke();
                                }
                        });

                        // ç«æŸ´äººé£æ ¼ç»˜åˆ¶

                        // ç»˜åˆ¶å¤´éƒ¨å¤§åœ†åœˆï¼ˆåœ¨å¤©ç©ºèƒŒæ™¯ä¸‹æ›´çªå‡ºï¼‰
                        if (pts[0] && pts[0].v > 0.5) {
                                // æ·»åŠ ç™½è‰²å…‰æ™•æ•ˆæœ
                                trunkCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                                trunkCtx.lineWidth = 6;
                                trunkCtx.beginPath();
                                trunkCtx.arc(pts[0].x, pts[0].y, 16, 0, 2 * Math.PI);
                                trunkCtx.stroke();

                                // ä¸»è¦å¤´éƒ¨åœ†åœˆ
                                trunkCtx.strokeStyle = '#ff6b6b';
                                trunkCtx.fillStyle = 'rgba(255, 107, 107, 0.7)';
                                trunkCtx.lineWidth = 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(pts[0].x, pts[0].y, 16, 0, 2 * Math.PI); // å¤§åœ†åœˆå¤´éƒ¨
                                trunkCtx.fill();
                                trunkCtx.stroke();

                                // ç»˜åˆ¶çœ¼ç›ï¼ˆé»‘ç‚¹ï¼‰
                                trunkCtx.fillStyle = '#000000';
                                trunkCtx.strokeStyle = '#000000';

                                // å·¦çœ¼ï¼ˆä»è§‚å¯Ÿè€…è§’åº¦çœ‹ï¼‰
                                const leftEyeX = pts[0].x - 5;
                                const leftEyeY = pts[0].y - 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(leftEyeX, leftEyeY, 2, 0, 2 * Math.PI);
                                trunkCtx.fill();

                                // å³çœ¼ï¼ˆä»è§‚å¯Ÿè€…è§’åº¦çœ‹ï¼‰
                                const rightEyeX = pts[0].x + 5;
                                const rightEyeY = pts[0].y - 3;
                                trunkCtx.beginPath();
                                trunkCtx.arc(rightEyeX, rightEyeY, 2, 0, 2 * Math.PI);
                                trunkCtx.fill();
                        }

                        // ç»˜åˆ¶å…³èŠ‚ç‚¹ï¼ˆå°åœ†åœˆï¼‰
                        // èº¯å¹²å…³èŠ‚ç‚¹ï¼ˆçº¢è‰²ï¼‰
                        trunkCtx.fillStyle = '#ff6b6b';
                        trunkCtx.strokeStyle = '#ff6b6b';
                        trunkCtx.lineWidth = 2;
                        [11, 12, 23, 24].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.5) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // æ‰‹è‡‚å…³èŠ‚ç‚¹ï¼ˆé’ç»¿è‰²ï¼‰
                        trunkCtx.fillStyle = '#4ecdc4';
                        trunkCtx.strokeStyle = '#4ecdc4';
                        [13, 14, 15, 16].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // åœ†å½¢æ‰‹æŒï¼ˆå¤šå•¦Aæ¢¦é£æ ¼ï¼‰
                        trunkCtx.fillStyle = '#00ffcc';
                        trunkCtx.strokeStyle = '#00ffcc';
                        trunkCtx.lineWidth = 2;

                        // å·¦æ‰‹æŒ - åŸºäºæ‰‹è…•ä½ç½® (index 15)
                        const leftWrist = pts[15];
                        if (leftWrist && leftWrist.v > 0.3) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(leftWrist.x, leftWrist.y, 8, 0, 2 * Math.PI); // åœ†å½¢æ‰‹æŒï¼ŒåŠå¾„8px
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // å³æ‰‹æŒ - åŸºäºæ‰‹è…•ä½ç½® (index 16)
                        const rightWrist = pts[16];
                        if (rightWrist && rightWrist.v > 0.3) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(rightWrist.x, rightWrist.y, 8, 0, 2 * Math.PI); // åœ†å½¢æ‰‹æŒï¼ŒåŠå¾„8px
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // è…¿éƒ¨å…³èŠ‚ç‚¹ï¼ˆæ©™è‰²ï¼‰
                        trunkCtx.fillStyle = '#ffa726';
                        trunkCtx.strokeStyle = '#ffa726';
                        [25, 26, 27, 28].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 4, 0, 2 * Math.PI);
                                        trunkCtx.fill();
                                        trunkCtx.stroke();
                                }
                        });

                        // è„šéƒ¨ï¼ˆå°åœ†ç‚¹ï¼‰
                        trunkCtx.fillStyle = '#ffa726';
                        [31, 32].forEach(idx => {
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        trunkCtx.beginPath();
                                        trunkCtx.arc(pt.x, pt.y, 6, 0, 2 * Math.PI); // è„šéƒ¨ç¨å¤§ä¸€ç‚¹
                                        trunkCtx.fill();
                                }
                        });

                        // ç»˜åˆ¶ä¸­å¿ƒç‚¹ï¼ˆç«æŸ´äººé£æ ¼ - æ›´å°æ›´ç®€æ´ï¼‰
                        trunkCtx.fillStyle = '#67d1ff';
                        trunkCtx.strokeStyle = '#67d1ff';
                        trunkCtx.lineWidth = 2;
                        if (shoulderCenter.v > 0.5) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(shoulderCenter.x, shoulderCenter.y, 3, 0, 2 * Math.PI);
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }
                        if (hipCenter.v > 0.5) {
                                trunkCtx.beginPath();
                                trunkCtx.arc(hipCenter.x, hipCenter.y, 3, 0, 2 * Math.PI);
                                trunkCtx.fill();
                                trunkCtx.stroke();
                        }

                        // ç«æŸ´äººæ ‡ç­¾ï¼ˆåœ¨å¤©ç©ºèƒŒæ™¯ä¸‹æ›´æ¸…æ™°ï¼‰
                        trunkCtx.fillStyle = '#ffffff';
                        trunkCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        trunkCtx.lineWidth = 3;
                        trunkCtx.font = 'bold 10px system-ui';

                        // æ ¹æ®é•œåƒçŠ¶æ€è°ƒæ•´æ–‡å­—å¯¹é½æ–¹å¼å’Œåç§»
                        const isMirrored = mirror.checked;
                        trunkCtx.textAlign = isMirrored ? 'right' : 'left';
                        const textOffsetX = isMirrored ? -20 : 20;
                        const smallTextOffsetX = isMirrored ? -8 : 8;

                        // Head label (with stroke effect)
                        if (pts[0] && pts[0].v > 0.5) {
                                trunkCtx.strokeText('Head', pts[0].x + textOffsetX, pts[0].y - 8);
                                trunkCtx.fillText('Head', pts[0].x + textOffsetX, pts[0].y - 8);
                        }

                        // æ‰‹æŒæ ‡ç­¾ï¼ˆå¤šå•¦Aæ¢¦é£æ ¼åœ†å½¢æ‰‹æŒï¼‰
                        trunkCtx.fillStyle = '#00ffcc';
                        trunkCtx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        trunkCtx.font = 'bold 9px system-ui';
                        trunkCtx.lineWidth = 2;

                        // å·¦æ‰‹æŒæ ‡ç­¾
                        if (pts[15] && pts[15].v > 0.3) {
                                const text = isMirrored ? 'R Hand' : 'L Hand';
                                trunkCtx.strokeText(text, pts[15].x + textOffsetX, pts[15].y + 15);
                                trunkCtx.fillText(text, pts[15].x + textOffsetX, pts[15].y + 15);
                        }

                        // å³æ‰‹æŒæ ‡ç­¾
                        if (pts[16] && pts[16].v > 0.3) {
                                const text = isMirrored ? 'L Hand' : 'R Hand';
                                trunkCtx.strokeText(text, pts[16].x + textOffsetX, pts[16].y + 15);
                                trunkCtx.fillText(text, pts[16].x + textOffsetX, pts[16].y + 15);
                        }

                        // Foot labels (simplified, with stroke)
                        if (pts[31] && pts[31].v > 0.3) {
                                const footText = isMirrored ? 'R Foot' : 'L Foot';
                                trunkCtx.strokeText(footText, pts[31].x + smallTextOffsetX, pts[31].y + 12);
                                trunkCtx.fillText(footText, pts[31].x + smallTextOffsetX, pts[31].y + 12);
                        }
                        if (pts[32] && pts[32].v > 0.3) {
                                const footText = isMirrored ? 'L Foot' : 'R Foot';
                                trunkCtx.strokeText(footText, pts[32].x + smallTextOffsetX, pts[32].y + 12);
                                trunkCtx.fillText(footText, pts[32].x + smallTextOffsetX, pts[32].y + 12);
                        }

                        trunkCtx.restore();
                }

                /**
                 * ç»˜åˆ¶æ‰‹éƒ¨å’Œè„šéƒ¨è¯¦ç»†çº¿æ®µ
                 * @param {CanvasRenderingContext2D} ctx - Canvasä¸Šä¸‹æ–‡
                 * @param {Array} pts - å…³é”®ç‚¹æ•°ç»„ï¼Œæ¯ä¸ªç‚¹åŒ…å«{x, y, z, v}
                 */
                function drawHandsAndFeetLines(ctx, pts) {
                        if (!pts || pts.length < 33) return; // MediaPipe Poseæœ‰33ä¸ªå…³é”®ç‚¹

                        ctx.save();
                        ctx.lineCap = 'round';

                        // æ‰‹éƒ¨è¿æ¥çº¿å®šä¹‰ï¼ˆæ ¹æ®MediaPipe Poseå…³é”®ç‚¹ç´¢å¼•ï¼‰
                        const handConnections = [
                                // å·¦æ‰‹
                                [11, 13], // å·¦è‚©åˆ°å·¦è‚˜
                                [13, 15], // å·¦è‚˜åˆ°å·¦æ‰‹è…•
                                [15, 17], // å·¦æ‰‹è…•åˆ°å·¦å°æŒ‡
                                [15, 19], // å·¦æ‰‹è…•åˆ°å·¦é£ŸæŒ‡
                                [15, 21], // å·¦æ‰‹è…•åˆ°å·¦æ‹‡æŒ‡
                                [17, 19], // å·¦å°æŒ‡åˆ°å·¦é£ŸæŒ‡

                                // å³æ‰‹
                                [12, 14], // å³è‚©åˆ°å³è‚˜
                                [14, 16], // å³è‚˜åˆ°å³æ‰‹è…•
                                [16, 18], // å³æ‰‹è…•åˆ°å³å°æŒ‡
                                [16, 20], // å³æ‰‹è…•åˆ°å³é£ŸæŒ‡
                                [16, 22], // å³æ‰‹è…•åˆ°å³æ‹‡æŒ‡
                                [18, 20], // å³å°æŒ‡åˆ°å³é£ŸæŒ‡
                        ];

                        // è„šéƒ¨è¿æ¥çº¿å®šä¹‰
                        const feetConnections = [
                                // å·¦è…¿å’Œè„š
                                [23, 25], // å·¦é«‹åˆ°å·¦è†
                                [25, 27], // å·¦è†åˆ°å·¦è¸
                                [27, 29], // å·¦è¸åˆ°å·¦è„šè·Ÿ
                                [27, 31], // å·¦è¸åˆ°å·¦è„šå°–
                                [29, 31], // å·¦è„šè·Ÿåˆ°å·¦è„šå°–

                                // å³è…¿å’Œè„š
                                [24, 26], // å³é«‹åˆ°å³è†
                                [26, 28], // å³è†åˆ°å³è¸
                                [28, 30], // å³è¸åˆ°å³è„šè·Ÿ
                                [28, 32], // å³è¸åˆ°å³è„šå°–
                                [30, 32], // å³è„šè·Ÿåˆ°å³è„šå°–
                        ];

                        // ç»˜åˆ¶æ‰‹éƒ¨çº¿æ®µï¼ˆç»¿è‰²ï¼‰
                        ctx.strokeStyle = '#4ecdc4'; // é’ç»¿è‰²
                        ctx.lineWidth = 3;
                        handConnections.forEach(([start, end]) => {
                                const startPt = pts[start];
                                const endPt = pts[end];

                                // åªæœ‰å½“ä¸¤ä¸ªç‚¹çš„å¯è§æ€§éƒ½è¶³å¤Ÿé«˜æ—¶æ‰ç»˜åˆ¶
                                if (startPt && endPt && startPt.v > 0.3 && endPt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // ç»˜åˆ¶è„šéƒ¨çº¿æ®µï¼ˆæ©™è‰²ï¼‰
                        ctx.strokeStyle = '#ffa726'; // æ©™è‰²
                        ctx.lineWidth = 3;
                        feetConnections.forEach(([start, end]) => {
                                const startPt = pts[start];
                                const endPt = pts[end];

                                // åªæœ‰å½“ä¸¤ä¸ªç‚¹çš„å¯è§æ€§éƒ½è¶³å¤Ÿé«˜æ—¶æ‰ç»˜åˆ¶
                                if (startPt && endPt && startPt.v > 0.3 && endPt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.moveTo(startPt.x, startPt.y);
                                        ctx.lineTo(endPt.x, endPt.y);
                                        ctx.stroke();
                                }
                        });

                        // ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹æ ‡è®°ï¼ˆç»¿è‰²ï¼‰
                        ctx.fillStyle = '#4ecdc4';
                        [15, 16, 17, 18, 19, 20, 21, 22].forEach(idx => { // æ‰‹è…•å’Œæ‰‹æŒ‡å…³é”®ç‚¹
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.arc(pt.x, pt.y, 2, 0, 2 * Math.PI);
                                        ctx.fill();
                                }
                        });

                        // ç»˜åˆ¶è„šéƒ¨å…³é”®ç‚¹æ ‡è®°ï¼ˆæ©™è‰²ï¼‰
                        ctx.fillStyle = '#ffa726';
                        [27, 28, 29, 30, 31, 32].forEach(idx => { // è¸éƒ¨å’Œè„šéƒ¨å…³é”®ç‚¹
                                const pt = pts[idx];
                                if (pt && pt.v > 0.3) {
                                        ctx.beginPath();
                                        ctx.arc(pt.x, pt.y, 2, 0, 2 * Math.PI);
                                        ctx.fill();
                                }
                        });

                        ctx.restore();
                }

                function drawLandmarksAndSkeleton(landmarks) {
                        const w = canvas.width, h = canvas.height;
                        ctx.save();
                        ctx.clearRect(0, 0, w, h);
                        if (mirror.checked) { ctx.translate(w, 0); ctx.scale(-1, 1); }
                        ctx.drawImage(video, 0, 0, w, h);
                        if (!landmarks || landmarks.length === 0) { ctx.restore(); return; }
                        const pts = landmarks.map(l => ({ x: l.x * w, y: l.y * h, z: l.z, v: l.visibility }));
                        drawConnectors(ctx, pts, POSE_CONNECTIONS, { lineWidth: 3 });
                        drawLandmarks(ctx, pts, { radius: 4 });
                        if (showIds.checked) {
                                ctx.font = '12px system-ui'; ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,.4)'; ctx.lineWidth = 3;
                                pts.forEach((p, i) => { ctx.strokeText(String(i), p.x + 4, p.y - 4); ctx.fillText(String(i), p.x + 4, p.y - 4); });
                        }
                        if (showBBox.checked) {
                                const xs = pts.map(p => p.x), ys = pts.map(p => p.y);
                                ctx.strokeStyle = '#67d1ff'; ctx.lineWidth = 2;
                                ctx.strokeRect(Math.min(...xs), Math.min(...ys), Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));
                        }
                        if (showTrunk.checked) {
                                drawTrunkLines(ctx, pts);
                        }
                        if (showHandsFeet.checked) {
                                drawHandsAndFeetLines(ctx, pts);
                        }
                        ctx.restore();
                }

                /**
 * å¼€å§‹å½•åˆ¶å§¿æ€æ•°æ®
 */
                function startRecording() {
                        if (isRecording) return;

                        isRecording = true;
                        recordingData = [];
                        recordingStartTime = Date.now();

                        recordBtn.disabled = true;
                        recordBtn.textContent = 'ğŸ”´ Recording...';
                        recordingStatus.style.display = 'block';

                        // Show recording status information
                        downloadInfo.style.display = 'block';
                        recordingInfo.textContent = 'ğŸ”´ Recording in progress...';
                        recordingInfo.style.color = '#ff6b6b';

                        // Countdown timer
                        let timeLeft = 20;
                        recordingTimer.textContent = timeLeft;

                        recordingInterval = setInterval(() => {
                                timeLeft--;
                                recordingTimer.textContent = timeLeft;
                                recordingInfo.textContent = `ğŸ”´ Recording... ${timeLeft}s remaining`;

                                if (timeLeft <= 0) {
                                        stopRecording();
                                }
                        }, 1000);

                        console.log('Starting animation data recording...');
                }

                /**
 * åœæ­¢å½•åˆ¶å§¿æ€æ•°æ®
 */
                function stopRecording() {
                        if (!isRecording) return;

                        isRecording = false;
                        clearInterval(recordingInterval);

                        recordBtn.disabled = false;
                        recordBtn.textContent = 'ğŸ¥ Record Animation';
                        recordingStatus.style.display = 'none';

                        // æ˜¾ç¤ºä¸‹è½½æŒ‰é’®
                        downloadBtn.style.display = 'inline-block';
                        downloadBtn.disabled = false;
                        manualDownloadBtn.style.display = 'inline-block';
                        manualDownloadBtn.disabled = false;

                        // æ›´æ–°çŠ¶æ€ä¿¡æ¯
                        recordingInfo.textContent = `âœ… Recording completed! ${recordingData.length} frames collected`;
                        recordingInfo.style.color = '#4ecdc4';

                        console.log(`Recording completed! Collected ${recordingData.length} frames of data`);
                        console.log('Download buttons enabled, recordingData:', recordingData.length > 0 ? 'has data' : 'no data');

                        // More friendly prompt
                        const message = `ğŸ‰ Recording completed!\n\nğŸ“Š Collected ${recordingData.length} animation frames\nğŸ’¾ Download buttons are now visible\nğŸ“± Click buttons to export Pivot format file`;
                        alert(message);
                }

                /**
                 * å°†MediaPipeå…³é”®ç‚¹è½¬æ¢ä¸ºPivot Animationæ ¼å¼
                 * @param {Array} landmarks - MediaPipeå§¿æ€å…³é”®ç‚¹
                 * @param {number} timestamp - æ—¶é—´æˆ³
                 * @returns {Object} Pivotæ ¼å¼çš„å¸§æ•°æ®
                 */
                function convertToPivotFrame(landmarks, timestamp) {
                        if (!landmarks || landmarks.length < 33) return null;

                        // Pivotä½¿ç”¨ç›¸å¯¹åæ ‡ç³»ç»Ÿï¼Œä»¥ç”»å¸ƒä¸­å¿ƒä¸ºåŸç‚¹
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const scale = 100; // ç¼©æ”¾å› å­

                        // ä¸»è¦å…³é”®ç‚¹æ˜ å°„åˆ°Pivotéª¨æ¶
                        const pivotPoints = {
                                // å¤´éƒ¨
                                head: {
                                        x: Math.round((landmarks[0].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[0].y * canvas.height - centerY) / scale)
                                },
                                // èº¯å¹²
                                neck: {
                                        x: Math.round(((landmarks[11].x + landmarks[12].x) / 2 * canvas.width - centerX) / scale),
                                        y: Math.round(((landmarks[11].y + landmarks[12].y) / 2 * canvas.height - centerY) / scale)
                                },
                                torso: {
                                        x: Math.round(((landmarks[23].x + landmarks[24].x) / 2 * canvas.width - centerX) / scale),
                                        y: Math.round(((landmarks[23].y + landmarks[24].y) / 2 * canvas.height - centerY) / scale)
                                },
                                // å·¦è‡‚
                                leftShoulder: {
                                        x: Math.round((landmarks[11].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[11].y * canvas.height - centerY) / scale)
                                },
                                leftElbow: {
                                        x: Math.round((landmarks[13].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[13].y * canvas.height - centerY) / scale)
                                },
                                leftHand: {
                                        x: Math.round((landmarks[15].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[15].y * canvas.height - centerY) / scale)
                                },
                                // å³è‡‚
                                rightShoulder: {
                                        x: Math.round((landmarks[12].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[12].y * canvas.height - centerY) / scale)
                                },
                                rightElbow: {
                                        x: Math.round((landmarks[14].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[14].y * canvas.height - centerY) / scale)
                                },
                                rightHand: {
                                        x: Math.round((landmarks[16].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[16].y * canvas.height - centerY) / scale)
                                },
                                // å·¦è…¿
                                leftHip: {
                                        x: Math.round((landmarks[23].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[23].y * canvas.height - centerY) / scale)
                                },
                                leftKnee: {
                                        x: Math.round((landmarks[25].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[25].y * canvas.height - centerY) / scale)
                                },
                                leftFoot: {
                                        x: Math.round((landmarks[27].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[27].y * canvas.height - centerY) / scale)
                                },
                                // å³è…¿
                                rightHip: {
                                        x: Math.round((landmarks[24].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[24].y * canvas.height - centerY) / scale)
                                },
                                rightKnee: {
                                        x: Math.round((landmarks[26].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[26].y * canvas.height - centerY) / scale)
                                },
                                rightFoot: {
                                        x: Math.round((landmarks[28].x * canvas.width - centerX) / scale),
                                        y: Math.round((landmarks[28].y * canvas.height - centerY) / scale)
                                }
                        };

                        return {
                                frame: Math.floor(timestamp / 50), // 20fps
                                points: pivotPoints
                        };
                }

                /**
                 * ç”ŸæˆPivot Animationæ ¼å¼çš„XMLæ–‡ä»¶å†…å®¹
                 * @param {Array} frames - åŠ¨ç”»å¸§æ•°æ®
                 * @returns {string} XMLæ ¼å¼çš„åŠ¨ç”»æ–‡ä»¶å†…å®¹
                 */
                function generatePivotXML(frames) {
                        const totalFrames = frames.length;
                        const fps = 20;

                        let xml = `<?xml version="1.0" encoding="UTF-8"?>
<animation>
    <info>
        <title>MediaPipeå§¿æ€åŠ¨ç”»</title>
        <author>MediaPipe Pose Recorder</author>
        <created>${new Date().toISOString()}</created>
        <frames>${totalFrames}</frames>
        <fps>${fps}</fps>
    </info>
    <figure>
        <segments>
            <!-- å¤´éƒ¨ -->
            <segment id="head" color="#FFD700"/>
            <!-- èº¯å¹² -->
            <segment id="neck" color="#FF6B6B"/>
            <segment id="torso" color="#FF6B6B"/>
            <!-- å·¦è‡‚ -->
            <segment id="leftArm1" color="#4ECDC4"/>
            <segment id="leftArm2" color="#4ECDC4"/>
            <!-- å³è‡‚ -->
            <segment id="rightArm1" color="#4ECDC4"/>
            <segment id="rightArm2" color="#4ECDC4"/>
            <!-- å·¦è…¿ -->
            <segment id="leftLeg1" color="#FFA726"/>
            <segment id="leftLeg2" color="#FFA726"/>
            <!-- å³è…¿ -->
            <segment id="rightLeg1" color="#FFA726"/>
            <segment id="rightLeg2" color="#FFA726"/>
        </segments>
    </figure>
    <frames>
`;

                        frames.forEach((frame, index) => {
                                const p = frame.points;
                                xml += `        <frame number="${index + 1}">
            <point id="head" x="${p.head.x}" y="${p.head.y}"/>
            <point id="neck" x="${p.neck.x}" y="${p.neck.y}"/>
            <point id="torso" x="${p.torso.x}" y="${p.torso.y}"/>
            <point id="leftShoulder" x="${p.leftShoulder.x}" y="${p.leftShoulder.y}"/>
            <point id="leftElbow" x="${p.leftElbow.x}" y="${p.leftElbow.y}"/>
            <point id="leftHand" x="${p.leftHand.x}" y="${p.leftHand.y}"/>
            <point id="rightShoulder" x="${p.rightShoulder.x}" y="${p.rightShoulder.y}"/>
            <point id="rightElbow" x="${p.rightElbow.x}" y="${p.rightElbow.y}"/>
            <point id="rightHand" x="${p.rightHand.x}" y="${p.rightHand.y}"/>
            <point id="leftHip" x="${p.leftHip.x}" y="${p.leftHip.y}"/>
            <point id="leftKnee" x="${p.leftKnee.x}" y="${p.leftKnee.y}"/>
            <point id="leftFoot" x="${p.leftFoot.x}" y="${p.leftFoot.y}"/>
            <point id="rightHip" x="${p.rightHip.x}" y="${p.rightHip.y}"/>
            <point id="rightKnee" x="${p.rightKnee.x}" y="${p.rightKnee.y}"/>
            <point id="rightFoot" x="${p.rightFoot.x}" y="${p.rightFoot.y}"/>
        </frame>
`;
                        });

                        xml += `    </frames>
</animation>`;

                        return xml;
                }

                /**
 * ä¸‹è½½PivotåŠ¨ç”»æ–‡ä»¶
 */
                function downloadPivotAnimation() {
                        console.log('Download function called, data frames:', recordingData.length);

                        if (recordingData.length === 0) {
                                alert('âŒ No recording data available for download\n\nPlease click "ğŸ¥ Record Animation" button to record for 20 seconds first.');
                                return;
                        }

                        try {
                                const xmlContent = generatePivotXML(recordingData);
                                console.log('XML content generated successfully, length:', xmlContent.length);

                                const blob = new Blob([xmlContent], { type: 'application/xml' });
                                const url = URL.createObjectURL(blob);

                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `pose_animation_${new Date().getTime()}.piv`;
                                a.style.display = 'none';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                                URL.revokeObjectURL(url);

                                console.log('âœ… Pivot animation file downloaded successfully');
                                alert('âœ… Animation file downloaded successfully!\n\nFilename: pose_animation_xxx.piv\nYou can open this file in Pivot Animator to view your animation.');
                        } catch (error) {
                                console.error('Error during download:', error);
                                alert('âŒ Download failed, please retry or refresh the page.\n\nError: ' + error.message);
                        }
                }

                /**
                 * å¼ºåˆ¶ä¸‹è½½å‡½æ•°ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
                 */
                function forceDownload() {
                        console.log('Force download triggered');
                        if (recordingData.length === 0) {
                                // åˆ›å»ºç¤ºä¾‹æ•°æ®ç”¨äºæµ‹è¯•
                                recordingData = [{
                                        frame: 0,
                                        points: {
                                                head: { x: 0, y: -50 },
                                                neck: { x: 0, y: -30 },
                                                torso: { x: 0, y: 20 },
                                                leftShoulder: { x: -20, y: -30 },
                                                leftElbow: { x: -40, y: -10 },
                                                leftHand: { x: -60, y: 10 },
                                                rightShoulder: { x: 20, y: -30 },
                                                rightElbow: { x: 40, y: -10 },
                                                rightHand: { x: 60, y: 10 },
                                                leftHip: { x: -10, y: 20 },
                                                leftKnee: { x: -10, y: 50 },
                                                leftFoot: { x: -10, y: 80 },
                                                rightHip: { x: 10, y: 20 },
                                                rightKnee: { x: 10, y: 50 },
                                                rightFoot: { x: 10, y: 80 }
                                        }
                                }];
                                alert('âš ï¸ Using sample data to create test file\n\nThis is a static test file, please record real motion data first.');
                        }
                        downloadPivotAnimation();
                }

                function onResults(results) {
                        drawLandmarksAndSkeleton(results.poseLandmarks);
                        drawTrunkOnly(results.poseLandmarks); // åœ¨å³ä¾§é¢æ¿æ˜¾ç¤ºèº¯å¹²

                        if (results.poseLandmarks) {
                                const pretty = results.poseLandmarks.map((l, i) => ({ i, x: +l.x.toFixed(4), y: +l.y.toFixed(4), z: +l.z.toFixed(4), v: +(l.visibility ?? 0).toFixed(3) }));
                                jsonOut.textContent = JSON.stringify(pretty, null, 2);

                                // å½•åˆ¶æœŸé—´æ”¶é›†å§¿æ€æ•°æ®
                                if (isRecording) {
                                        const timestamp = Date.now() - recordingStartTime;
                                        const pivotFrame = convertToPivotFrame(results.poseLandmarks, timestamp);
                                        if (pivotFrame) {
                                                recordingData.push(pivotFrame);
                                        }
                                }
                        } else {
                                jsonOut.textContent = '[]';
                        }
                }

                const pose = new Pose({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
                pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, smoothSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                pose.onResults(onResults);

                async function start() {
                        setStatus('Initializing camera...');
                        try {
                                // è¯·æ±‚æ‘„åƒå¤´å‰å…ˆç¡®è®¤æƒé™
                                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                                video.srcObject = stream;
                                await video.play();
                                camera = new Camera(video, { onFrame: async () => await pose.send({ image: video }), width: 1280, height: 720 });
                                await camera.start();
                                fitCanvasToVideo();
                                setStatus('Running', true);
                                startBtn.disabled = true;
                                stopBtn.disabled = false;
                                recordBtn.disabled = false; // å¯ç”¨å½•åˆ¶æŒ‰é’®
                                window.addEventListener('resize', fitCanvasToVideo);
                        } catch (err) {
                                console.error(err);
                                alert('Camera failed to start. Please check browser permissions and ensure page is accessed via HTTPS or localhost.\nError: ' + err.message);
                                setStatus('Start Failed');
                        }
                }

                async function stop() {
                        setStatus('Stopped');
                        if (camera) { camera.stop(); camera = null; }
                        if (video.srcObject) { video.srcObject.getTracks().forEach(t => t.stop()); video.srcObject = null; }
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                        recordBtn.disabled = true; // ç¦ç”¨å½•åˆ¶æŒ‰é’®
                        if (isRecording) stopRecording(); // å¦‚æœæ­£åœ¨å½•åˆ¶ï¼Œåœæ­¢å½•åˆ¶
                        window.removeEventListener('resize', fitCanvasToVideo);
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        trunkCtx.clearRect(0, 0, trunkCanvas.width, trunkCanvas.height);
                }

                startBtn.addEventListener('click', start);
                stopBtn.addEventListener('click', stop);
                recordBtn.addEventListener('click', startRecording);
                downloadBtn.addEventListener('click', downloadPivotAnimation);
                manualDownloadBtn.addEventListener('click', forceDownload);
                document.addEventListener('visibilitychange', () => { if (document.hidden && camera) stop(); });

                // å“åº”å¼å¸ƒå±€ï¼šç›‘å¬çª—å£å¤§å°å˜åŒ–
                let resizeTimeout;
                window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                                if (camera) {
                                        fitCanvasToVideo();
                                }
                        }, 250); // é˜²æŠ–åŠ¨ï¼Œ250msåæ‰§è¡Œ
                });

                // è®¾å¤‡æ–¹å‘å˜åŒ–ç›‘å¬
                window.addEventListener('orientationchange', () => {
                        setTimeout(() => {
                                if (camera) {
                                        fitCanvasToVideo();
                                }
                        }, 500); // ç­‰å¾…æ–¹å‘å˜åŒ–å®Œæˆ
                });

                // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–ç«æŸ´äººcanvas
                window.addEventListener('load', () => {
                        setTimeout(() => {
                                fitCanvasToVideo();
                        }, 100);
                });
        </script>
</body>

</html>

</html>
